import express from 'express'
import jwt from 'jsonwebtoken'
import bcrypt from 'bcryptjs'
import multer from 'multer'
import sharp from 'sharp'
import nodemailer from 'nodemailer'
import rateLimit from 'express-rate-limit'
import helmet from 'helmet'
import cors from 'cors'
import { body, param, validationResult } from 'express-validator'
import { PrismaClient } from '@prisma/client'
import Redis from 'ioredis'
import AWS from 'aws-sdk'
import { v4 as uuidv4 } from 'uuid'
import crypto from 'crypto'
import { promisify } from 'util'
import fs from 'fs/promises'
import path from 'path'
import FormData from 'form-data'
import axios from 'axios'
import moment from 'moment'
import validator from 'validator'
import speakeasy from 'speakeasy'
import qrcode from 'qrcode'
import geoip from 'geoip-lite'
import useragent from 'useragent'
import winston from 'winston'
import compression from 'compression'
import cookieParser from 'cookie-parser'
import session from 'express-session'
import MongoStore from 'connect-mongo'
import passport from 'passport'
import { Readable } from 'stream'
import csvParser from 'csv-parser'
import ExcelJS from 'exceljs'
import PDFDocument from 'pdfkit'
import archiver from 'archiver'
import cheerio from 'cheerio'
import puppeteer from 'puppeteer'
import cron from 'node-cron'
import webpush from 'web-push'
import socketio from 'socket.io'
import amqp from 'amqplib'
import Stripe from 'stripe'
import Twilio from 'twilio'
import SendGrid from '@sendgrid/mail'
import CloudFlare from 'cloudflare'
import Sentry from '@sentry/node'
import DataLoader from 'dataloader'
import { GraphQLSchema, GraphQLObjectType, GraphQLString, GraphQLInt, GraphQLList, GraphQLNonNull, GraphQLBoolean, GraphQLFloat } from 'graphql'

const app = express()
const router = express.Router()

const prisma = new PrismaClient()
const redis = new Redis(process.env.REDIS_URL)
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY)
const twilio = Twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN)
const cloudflare = new CloudFlare({ email: process.env.CLOUDFLARE_EMAIL, key: process.env.CLOUDFLARE_API_KEY })

SendGrid.setApiKey(process.env.SENDGRID_API_KEY)

const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION
})

const ses = new AWS.SES({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_SES_REGION
})

const dynamodb = new AWS.DynamoDB.DocumentClient({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION
})

const sns = new AWS.SNS({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION
})

const sqs = new AWS.SQS({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION
})

webpush.setVapidDetails(
  'mailto:' + process.env.WEB_PUSH_EMAIL,
  process.env.WEB_PUSH_PUBLIC_KEY,
  process.env.WEB_PUSH_PRIVATE_KEY
)

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
})

const userLoader = new DataLoader(async (userIds) => {
  const users = await prisma.user.findMany({
    where: { id: { in: userIds } },
    include: {
      profile: true,
      permissions: true,
      subscriptions: true,
      activities: true,
      notifications: true,
      sessions: true,
      devices: true,
      socialAccounts: true,
      paymentMethods: true,
      transactions: true,
      analytics: true,
      preferences: true
    }
  })
  return userIds.map(id => users.find(user => user.id === id))
})

const storage = multer.memoryStorage()
const upload = multer({ 
  storage,
  limits: { 
    fileSize: 50 * 1024 * 1024, // 50MB
    files: 10 
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'application/pdf', 'text/csv', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet']
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true)
    } else {
      cb(new Error('Invalid file type'), false)
    }
  }
})

const createRateLimit = (windowMs, max, message) => rateLimit({
  windowMs,
  max,
  message: { error: message },
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req) => {
    return req.ip + ':' + (req.user?.id || 'anonymous')
  }
})

const strictRateLimit = createRateLimit(15 * 60 * 1000, 100, 'Too many requests')
const loginRateLimit = createRateLimit(15 * 60 * 1000, 5, 'Too many login attempts')
const uploadRateLimit = createRateLimit(60 * 60 * 1000, 20, 'Too many upload requests')

app.use(helmet())
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept', 'Origin']
}))
app.use(compression())
app.use(express.json({ limit: '10mb' }))
app.use(express.urlencoded({ extended: true, limit: '10mb' }))
app.use(cookieParser())

app.use(session({
  secret: process.env.SESSION_SECRET || 'fallback-secret',
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({
    mongoUrl: process.env.MONGODB_URL
  }),
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000 // 24 hours
  }
}))

app.use(passport.initialize())
app.use(passport.session())

const authenticateJWT = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization
    const token = authHeader && authHeader.split(' ')[1]

    if (!token) {
      return res.status(401).json({ error: 'Access token required' })
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET)
    const user = await userLoader.load(decoded.userId)

    if (!user || !user.isActive) {
      return res.status(401).json({ error: 'Invalid or inactive user' })
    }

    const session = await redis.get(`session:${decoded.sessionId}`)
    if (!session) {
      return res.status(401).json({ error: 'Session expired' })
    }

    req.user = user
    req.sessionId = decoded.sessionId
    next()
  } catch (error) {
    logger.error('Authentication error:', error)
    return res.status(401).json({ error: 'Invalid token' })
  }
}

const validateRequest = (req, res, next) => {
  const errors = validationResult(req)
  if (!errors.isEmpty()) {
    return res.status(400).json({
      error: 'Validation failed',
      details: errors.array()
    })
  }
  next()
}

const generateDeviceFingerprint = (req) => {
  const agent = useragent.parse(req.headers['user-agent'])
  const geo = geoip.lookup(req.ip)
  
  return crypto.createHash('sha256')
    .update(`${agent.family}-${agent.os.family}-${req.ip}-${geo?.country || 'unknown'}`)
    .digest('hex')
}

const logActivity = async (userId, action, details = {}) => {
  try {
    await prisma.activity.create({
      data: {
        userId,
        action,
        details: JSON.stringify(details),
        timestamp: new Date(),
        ipAddress: details.ipAddress,
        userAgent: details.userAgent,
        location: details.location
      }
    })

    await dynamodb.put({
      TableName: 'UserActivities',
      Item: {
        id: uuidv4(),
        userId,
        action,
        timestamp: Date.now(),
        details
      }
    }).promise()
  } catch (error) {
    logger.error('Activity logging error:', error)
  }
}

let rabbitmqConnection = null
let rabbitmqChannel = null

const initializeMessageQueue = async () => {
  try {
    rabbitmqConnection = await amqp.connect(process.env.RABBITMQ_URL || 'amqp://localhost')
    rabbitmqChannel = await rabbitmqConnection.createChannel()
    
    await rabbitmqChannel.assertQueue('email_queue', { durable: true })
    await rabbitmqChannel.assertQueue('analytics_queue', { durable: true })
    await rabbitmqChannel.assertQueue('notification_queue', { durable: true })
    
    logger.info('RabbitMQ initialized successfully')
  } catch (error) {
    logger.error('RabbitMQ initialization failed:', error)
  }
}

initializeMessageQueue()

const sendEmail = async (to, subject, html, attachments = []) => {
  try {
    const msg = {
      to,
      from: process.env.FROM_EMAIL,
      subject,
      html,
      attachments
    }

    if (process.env.USE_SENDGRID === 'true') {
      await SendGrid.send(msg)
    } else {
      const sesParams = {
        Destination: { ToAddresses: [to] },
        Message: {
          Body: { Html: { Charset: 'UTF-8', Data: html } },
          Subject: { Charset: 'UTF-8', Data: subject }
        },
        Source: process.env.FROM_EMAIL
      }
      await ses.sendEmail(sesParams).promise()
    }

    logger.info(`Email sent to ${to}`)
  } catch (error) {
    logger.error('Email sending error:', error)
    throw error
  }
}

const sendPushNotification = async (subscription, payload) => {
  try {
    await webpush.sendNotification(subscription, JSON.stringify(payload))
    logger.info('Push notification sent successfully')
  } catch (error) {
    logger.error('Push notification error:', error)
    throw error
  }
}

const processImage = async (buffer, options = {}) => {
  try {
    const { width = 800, height = 600, quality = 80, format = 'jpeg' } = options
    
    return await sharp(buffer)
      .resize(width, height, { fit: 'inside', withoutEnlargement: true })
      .toFormat(format, { quality })
      .toBuffer()
  } catch (error) {
    logger.error('Image processing error:', error)
    throw error
  }
}

const uploadToS3 = async (buffer, key, contentType) => {
  try {
    const params = {
      Bucket: process.env.AWS_S3_BUCKET,
      Key: key,
      Body: buffer,
      ContentType: contentType,
      ACL: 'public-read'
    }

    const result = await s3.upload(params).promise()
    return result.Location
  } catch (error) {
    logger.error('S3 upload error:', error)
    throw error
  }
}

const processCSV = async (buffer) => {
  return new Promise((resolve, reject) => {
    const results = []
    const stream = Readable.from(buffer.toString())
    
    stream
      .pipe(csvParser())
      .on('data', (data) => results.push(data))
      .on('end', () => resolve(results))
      .on('error', reject)
  })
}

const processExcel = async (buffer) => {
  try {
    const workbook = new ExcelJS.Workbook()
    await workbook.xlsx.load(buffer)
    
    const worksheet = workbook.getWorksheet(1)
    const data = []
    
    worksheet.eachRow((row, rowNumber) => {
      if (rowNumber > 1) { // Skip header
        data.push(row.values)
      }
    })
    
    return data
  } catch (error) {
    logger.error('Excel processing error:', error)
    throw error
  }
}

const generatePDF = async (data) => {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument()
      const chunks = []
      
      doc.on('data', chunk => chunks.push(chunk))
      doc.on('end', () => resolve(Buffer.concat(chunks)))
      doc.on('error', reject)
      
      doc.fontSize(20).text('User Analytics Report', 100, 100)
      doc.fontSize(12).text(`Generated on: ${moment().format('YYYY-MM-DD HH:mm:ss')}`, 100, 130)
      
      let yPosition = 160
      Object.entries(data).forEach(([key, value]) => {
        doc.text(`${key}: ${value}`, 100, yPosition)
        yPosition += 20
      })
      
      doc.end()
    } catch (error) {
      reject(error)
    }
  })
}

const processAnalytics = async (userId, eventType, eventData) => {
  try {
    const key = `analytics:${userId}:${moment().format('YYYY-MM-DD')}`
    await redis.hincrby(key, eventType, 1)
    await redis.expire(key, 7 * 24 * 60 * 60) // 7 days TTL

    await dynamodb.put({
      TableName: 'UserAnalytics',
      Item: {
        id: uuidv4(),
        userId,
        eventType,
        eventData,
        timestamp: Date.now(),
        date: moment().format('YYYY-MM-DD'),
        hour: moment().hour()
      }
    }).promise()

    if (rabbitmqChannel) {
      await rabbitmqChannel.sendToQueue(
        'analytics_queue',
        Buffer.from(JSON.stringify({ userId, eventType, eventData, timestamp: Date.now() })),
        { persistent: true }
      )
    }
  } catch (error) {
    logger.error('Analytics processing error:', error)
  }
}

const scrapeWebsite = async (url) => {
  let browser = null
  try {
    browser = await puppeteer.launch({ headless: true })
    const page = await browser.newPage()
    
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36')
    await page.goto(url, { waitUntil: 'networkidle2' })
    
    const content = await page.evaluate(() => {
      return {
        title: document.title,
        description: document.querySelector('meta[name="description"]')?.content || '',
        text: document.body.innerText.slice(0, 1000) // First 1000 chars
      }
    })
    
    return content
  } catch (error) {
    logger.error('Web scraping error:', error)
    throw error
  } finally {
    if (browser) await browser.close()
  }
}

const processPayment = async (amount, currency, paymentMethodId, customerId) => {
  try {
    const paymentIntent = await stripe.paymentIntents.create({
      amount: amount * 100, // Convert to cents
      currency,
      payment_method: paymentMethodId,
      customer: customerId,
      confirm: true,
      automatic_payment_methods: { enabled: true, allow_redirects: 'never' }
    })

    return paymentIntent
  } catch (error) {
    logger.error('Payment processing error:', error)
    throw error
  }
}

const generate2FA = () => {
  const secret = speakeasy.generateSecret({
    name: 'YourApp',
    length: 32
  })
  
  return {
    secret: secret.base32,
    qrCode: qrcode.toDataURL(secret.otpauth_url)
  }
}

const verify2FA = (token, secret) => {
  return speakeasy.totp.verify({
    secret,
    encoding: 'base32',
    token,
    window: 2
  })
}


app.post('/api/users/register',
  strictRateLimit,
  upload.single('avatar'),
  [
    body('email').isEmail().normalizeEmail(),
    body('password').isLength({ min: 8 }).matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/),
    body('firstName').trim().isLength({ min: 2, max: 50 }),
    body('lastName').trim().isLength({ min: 2, max: 50 }),
    body('phoneNumber').optional().isMobilePhone(),
    body('dateOfBirth').optional().isISO8601(),
    body('termsAccepted').isBoolean().equals('true')
  ],
  validateRequest,
  async (req, res) => {
    try {
      const {
        email,
        password,
        firstName,
        lastName,
        phoneNumber,
        dateOfBirth,
        preferences = {},
        marketingOptIn = false
      } = req.body

      const existingUser = await prisma.user.findUnique({ where: { email } })
      if (existingUser) {
        return res.status(400).json({ error: 'User already exists' })
      }

      const saltRounds = 12
      const hashedPassword = await bcrypt.hash(password, saltRounds)

      const verificationToken = crypto.randomBytes(32).toString('hex')

      let avatarUrl = null
      if (req.file) {
        const processedImage = await processImage(req.file.buffer, {
          width: 300,
          height: 300,
          quality: 85,
          format: 'jpeg'
        })
        
        const avatarKey = `avatars/${uuidv4()}.jpg`
        avatarUrl = await uploadToS3(processedImage, avatarKey, 'image/jpeg')
      }

      const deviceFingerprint = generateDeviceFingerprint(req)
      const geo = geoip.lookup(req.ip)
      const agent = useragent.parse(req.headers['user-agent'])

      const twoFactorSecret = generate2FA()

      const user = await prisma.$transaction(async (tx) => {
        const newUser = await tx.user.create({
          data: {
            email,
            password: hashedPassword,
            firstName,
            lastName,
            phoneNumber,
            dateOfBirth: dateOfBirth ? new Date(dateOfBirth) : null,
            avatarUrl,
            isActive: false,
            emailVerified: false,
            verificationToken,
            twoFactorSecret: twoFactorSecret.secret,
            marketingOptIn,
            registrationIp: req.ip,
            lastLoginIp: req.ip,
            deviceFingerprint,
            profile: {
              create: {
                bio: '',
                location: geo ? `${geo.city}, ${geo.country}` : null,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                language: 'en',
                theme: 'light'
              }
            },
            preferences: {
              create: {
                notifications: preferences.notifications || {
                  email: true,
                  push: true,
                  sms: false,
                  marketing: marketingOptIn
                },
                privacy: preferences.privacy || {
                  profileVisibility: 'public',
                  activityVisibility: 'friends',
                  searchable: true
                },
                display: preferences.display || {
                  theme: 'light',
                  language: 'en',
                  timezone: 'UTC'
                }
              }
            },
            analytics: {
              create: {
                registrationDate: new Date(),
                registrationSource: req.headers.referer || 'direct',
                deviceType: agent.device.family || 'desktop',
                browser: agent.family,
                os: agent.os.family,
                country: geo?.country,
                city: geo?.city,
                totalLogins: 0,
                lastActivity: new Date()
              }
            }
          },
          include: {
            profile: true,
            preferences: true,
            analytics: true
          }
        })

        await tx.subscription.create({
          data: {
            userId: newUser.id,
            plan: 'free',
            status: 'active',
            startDate: new Date(),
            features: JSON.stringify({
              maxStorage: '1GB',
              maxApiCalls: 1000,
              supportLevel: 'basic'
            })
          }
        })

        return newUser
      })

      const qrCodeDataUrl = await qrcode.toDataURL(twoFactorSecret.qrCode)

      const verificationUrl = `${process.env.FRONTEND_URL}/verify-email?token=${verificationToken}`
      const emailHtml = `
        <h1>Welcome to YourApp!</h1>
        <p>Please verify your email address by clicking the link below:</p>
        <a href="${verificationUrl}">Verify Email</a>
        <p>This link will expire in 24 hours.</p>
      `

      if (rabbitmqChannel) {
        await rabbitmqChannel.sendToQueue(
          'email_queue',
          Buffer.from(JSON.stringify({
            to: email,
            subject: 'Welcome to YourApp - Verify Your Email',
            html: emailHtml,
            priority: 'high'
          })),
          { persistent: true }
        )
      }

      await logActivity(user.id, 'USER_REGISTERED', {
        ipAddress: req.ip,
        userAgent: req.headers['user-agent'],
        location: geo ? `${geo.city}, ${geo.country}` : null,
        deviceFingerprint
      })

      await processAnalytics(user.id, 'registration', {
        source: req.headers.referer || 'direct',
        deviceType: agent.device.family || 'desktop',
        browser: agent.family,
        os: agent.os.family
      })

      if (phoneNumber) {
        try {
          await twilio.messages.create({
            body: `Welcome to YourApp! Your account has been created successfully. Please verify your email to complete registration.`,
            from: process.env.TWILIO_PHONE_NUMBER,
            to: phoneNumber
          })
        } catch (smsError) {
          logger.error('SMS sending error:', smsError)
        }
      }

      let stripeCustomerId = null
      try {
        const stripeCustomer = await stripe.customers.create({
          email,
          name: `${firstName} ${lastName}`,
          phone: phoneNumber,
          metadata: {
            userId: user.id
          }
        })
        stripeCustomerId = stripeCustomer.id

        await prisma.user.update({
          where: { id: user.id },
          data: { stripeCustomerId }
        })
      } catch (stripeError) {
        logger.error('Stripe customer creation error:', stripeError)
      }

      if (preferences.customSubdomain) {
        try {
          await cloudflare.dnsRecords.add(process.env.CLOUDFLARE_ZONE_ID, {
            type: 'CNAME',
            name: preferences.customSubdomain,
            content: process.env.MAIN_DOMAIN,
            ttl: 1
          })
        } catch (cfError) {
          logger.error('CloudFlare DNS error:', cfError)
        }
      }

      await redis.setex(`user:${user.id}`, 3600, JSON.stringify({
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        isActive: user.isActive,
        emailVerified: user.emailVerified
      }))

      const { password: _, verificationToken: __, twoFactorSecret: ___, ...safeUserData } = user

      res.status(201).json({
        success: true,
        message: 'User registered successfully. Please check your email for verification.',
        user: safeUserData,
        twoFactorQR: qrCodeDataUrl,
        stripeCustomerId
      })

    } catch (error) {
      logger.error('Registration error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Registration failed' })
    }
  }
)

app.post('/api/users/login',
  loginRateLimit,
  [
    body('email').isEmail().normalizeEmail(),
    body('password').notEmpty(),
    body('twoFactorToken').optional().isLength({ min: 6, max: 6 }),
    body('deviceTrust').optional().isBoolean()
  ],
  validateRequest,
  async (req, res) => {
    try {
      const { email, password, twoFactorToken, deviceTrust = false } = req.body

      const user = await prisma.user.findUnique({
        where: { email },
        include: {
          profile: true,
          preferences: true,
          sessions: true,
          devices: true,
          analytics: true
        }
      })

      if (!user) {
        return res.status(401).json({ error: 'Invalid credentials' })
      }

      if (!user.isActive) {
        return res.status(401).json({ error: 'Account is inactive' })
      }

      const isValidPassword = await bcrypt.compare(password, user.password)
      if (!isValidPassword) {
        await logActivity(user.id, 'LOGIN_FAILED', {
          reason: 'invalid_password',
          ipAddress: req.ip,
          userAgent: req.headers['user-agent']
        })
        return res.status(401).json({ error: 'Invalid credentials' })
      }

      if (user.twoFactorEnabled && twoFactorToken) {
        const isValid2FA = verify2FA(twoFactorToken, user.twoFactorSecret)
        if (!isValid2FA) {
          await logActivity(user.id, 'LOGIN_FAILED', {
            reason: 'invalid_2fa',
            ipAddress: req.ip,
            userAgent: req.headers['user-agent']
          })
          return res.status(401).json({ error: 'Invalid 2FA token' })
        }
      } else if (user.twoFactorEnabled && !twoFactorToken) {
        return res.status(401).json({ 
          error: '2FA token required',
          requiresTwoFactor: true 
        })
      }

      const deviceFingerprint = generateDeviceFingerprint(req)
      const geo = geoip.lookup(req.ip)
      const agent = useragent.parse(req.headers['user-agent'])

      const trustedDevice = await prisma.device.findFirst({
        where: {
          userId: user.id,
          fingerprint: deviceFingerprint,
          trusted: true
        }
      })

      if (!trustedDevice && !twoFactorToken && user.twoFactorEnabled) {
        const emailHtml = `
          <h2>New Device Login Attempt</h2>
          <p>Someone attempted to login to your account from a new device:</p>
          <p><strong>IP Address:</strong> ${req.ip}</p>
          <p><strong>Location:</strong> ${geo ? `${geo.city}, ${geo.country}` : 'Unknown'}</p>
          <p><strong>Device:</strong> ${agent.family} on ${agent.os.family}</p>
          <p><strong>Time:</strong> ${new Date().toISOString()}</p>
          <p>If this was you, please use your 2FA token to complete login. If not, please secure your account immediately.</p>
        `

        if (rabbitmqChannel) {
          await rabbitmqChannel.sendToQueue(
            'email_queue',
            Buffer.from(JSON.stringify({
              to: email,
              subject: 'New Device Login Attempt',
              html: emailHtml,
              priority: 'high'
            })),
            { persistent: true }
          )
        }

        return res.status(401).json({ 
          error: 'New device detected. 2FA required.',
          requiresTwoFactor: true,
          newDevice: true
        })
      }

      const sessionId = uuidv4()
      const sessionToken = jwt.sign(
        { 
          userId: user.id, 
          sessionId,
          deviceFingerprint 
        },
        process.env.JWT_SECRET,
        { 
          expiresIn: deviceTrust ? '30d' : '7d',
          issuer: 'yourapp',
          audience: 'yourapp-users'
        }
      )

      const sessionData = {
        userId: user.id,
        deviceFingerprint,
        ipAddress: req.ip,
        userAgent: req.headers['user-agent'],
        location: geo ? `${geo.city}, ${geo.country}` : null,
        loginTime: Date.now(),
        trusted: deviceTrust || !!trustedDevice
      }

      await redis.setex(
        `session:${sessionId}`,
        deviceTrust ? 30 * 24 * 60 * 60 : 7 * 24 * 60 * 60, // 30 days or 7 days
        JSON.stringify(sessionData)
      )

      await prisma.session.create({
        data: {
          id: sessionId,
          userId: user.id,
          token: sessionToken,
          deviceFingerprint,
          ipAddress: req.ip,
          userAgent: req.headers['user-agent'],
          location: geo ? `${geo.city}, ${geo.country}` : null,
          trusted: deviceTrust || !!trustedDevice,
          expiresAt: new Date(Date.now() + (deviceTrust ? 30 : 7) * 24 * 60 * 60 * 1000)
        }
      })

      if (!trustedDevice) {
        await prisma.device.upsert({
          where: {
            userId_fingerprint: {
              userId: user.id,
              fingerprint: deviceFingerprint
            }
          },
          update: {
            lastSeen: new Date(),
            ipAddress: req.ip,
            location: geo ? `${geo.city}, ${geo.country}` : null
          },
          create: {
            userId: user.id,
            fingerprint: deviceFingerprint,
            deviceName: `${agent.family} on ${agent.os.family}`,
            deviceType: agent.device.family || 'desktop',
            trusted: deviceTrust,
            ipAddress: req.ip,
            location: geo ? `${geo.city}, ${geo.country}` : null,
            lastSeen: new Date()
          }
        })
      }

      await prisma.$transaction([
        prisma.user.update({
          where: { id: user.id },
          data: {
            lastLoginAt: new Date(),
            lastLoginIp: req.ip,
            loginCount: { increment: 1 }
          }
        }),
        prisma.userAnalytics.update({
          where: { userId: user.id },
          data: {
            totalLogins: { increment: 1 },
            lastActivity: new Date(),
            lastLoginCountry: geo?.country,
            lastLoginCity: geo?.city
          }
        })
      ])

      await processAnalytics(user.id, 'login', {
        deviceType: agent.device.family || 'desktop',
        browser: agent.family,
        os: agent.os.family,
        country: geo?.country,
        city: geo?.city,
        trusted: deviceTrust || !!trustedDevice
      })

      await logActivity(user.id, 'LOGIN_SUCCESS', {
        ipAddress: req.ip,
        userAgent: req.headers['user-agent'],
        location: geo ? `${geo.city}, ${geo.country}` : null,
        deviceFingerprint,
        sessionId
      })

      await redis.setex(`user:${user.id}`, 3600, JSON.stringify({
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        isActive: user.isActive,
        emailVerified: user.emailVerified,
        lastActivity: Date.now()
      }))

      if (user.preferences?.notifications?.email && !trustedDevice) {
        const loginNotificationHtml = `
          <h2>New Login to Your Account</h2>
          <p>Your account was accessed from:</p>
          <p><strong>IP Address:</strong> ${req.ip}</p>
          <p><strong>Location:</strong> ${geo ? `${geo.city}, ${geo.country}` : 'Unknown'}</p>
          <p><strong>Device:</strong> ${agent.family} on ${agent.os.family}</p>
          <p><strong>Time:</strong> ${new Date().toISOString()}</p>
          <p>If this wasn't you, please secure your account immediately.</p>
        `

        if (rabbitmqChannel) {
          await rabbitmqChannel.sendToQueue(
            'email_queue',
            Buffer.from(JSON.stringify({
              to: email,
              subject: 'New Login to Your Account',
              html: loginNotificationHtml,
              priority: 'normal'
            })),
            { persistent: true }
          )
        }
      }

      if (user.preferences?.notifications?.push) {
        const pushSubscriptions = await prisma.pushSubscription.findMany({
          where: { userId: user.id, active: true }
        })

        for (const subscription of pushSubscriptions) {
          try {
            await sendPushNotification(JSON.parse(subscription.subscription), {
              title: 'New Login',
              body: `Login from ${geo ? `${geo.city}, ${geo.country}` : 'unknown location'}`,
              icon: '/icon-192x192.png',
              badge: '/badge-72x72.png',
              data: {
                type: 'login',
                timestamp: Date.now()
              }
            })
          } catch (pushError) {
            logger.error('Push notification error:', pushError)
          }
        }
      }

      const oldSessions = await prisma.session.findMany({
        where: { userId: user.id },
        orderBy: { createdAt: 'desc' },
        skip: 5
      })

      if (oldSessions.length > 0) {
        const oldSessionIds = oldSessions.map(s => s.id)
        await prisma.session.deleteMany({
          where: { id: { in: oldSessionIds } }
        })

        for (const oldSession of oldSessions) {
          await redis.del(`session:${oldSession.id}`)
        }
      }

      const { password: _, verificationToken: __, twoFactorSecret: ___, ...safeUserData } = user

      res.json({
        success: true,
        message: 'Login successful',
        token: sessionToken,
        user: safeUserData,
        session: {
          id: sessionId,
          expiresAt: sessionData.loginTime + (deviceTrust ? 30 : 7) * 24 * 60 * 60 * 1000
        },
        newDevice: !trustedDevice
      })

    } catch (error) {
      logger.error('Login error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Login failed' })
    }
  }
)

app.put('/api/users/profile',
  strictRateLimit,
  authenticateJWT,
  upload.fields([
    { name: 'avatar', maxCount: 1 },
    { name: 'cover', maxCount: 1 },
    { name: 'documents', maxCount: 5 }
  ]),
  [
    body('firstName').optional().trim().isLength({ min: 2, max: 50 }),
    body('lastName').optional().trim().isLength({ min: 2, max: 50 }),
    body('bio').optional().isLength({ max: 500 }),
    body('website').optional().isURL(),
    body('location').optional().isLength({ max: 100 }),
    body('dateOfBirth').optional().isISO8601(),
    body('phoneNumber').optional().isMobilePhone(),
    body('socialLinks').optional().isJSON(),
    body('skills').optional().isJSON(),
    body('interests').optional().isJSON()
  ],
  validateRequest,
  async (req, res) => {
    try {
      const userId = req.user.id
      const {
        firstName,
        lastName,
        bio,
        website,
        location,
        dateOfBirth,
        phoneNumber,
        socialLinks = '{}',
        skills = '[]',
        interests = '[]',
        privacy = '{}'
      } = req.body

      const parsedSocialLinks = JSON.parse(socialLinks)
      const parsedSkills = JSON.parse(skills)
      const parsedInterests = JSON.parse(interests)
      const parsedPrivacy = JSON.parse(privacy)

      const uploadedFiles = {
        avatarUrl: null,
        coverUrl: null,
        documentUrls: []
      }

      if (req.files) {
        if (req.files.avatar && req.files.avatar[0]) {
          const avatarFile = req.files.avatar[0]
          const processedAvatar = await processImage(avatarFile.buffer, {
            width: 400,
            height: 400,
            quality: 90,
            format: 'jpeg'
          })
          
          const avatarKey = `avatars/${userId}/${uuidv4()}.jpg`
          uploadedFiles.avatarUrl = await uploadToS3(processedAvatar, avatarKey, 'image/jpeg')
        }

        if (req.files.cover && req.files.cover[0]) {
          const coverFile = req.files.cover[0]
          const processedCover = await processImage(coverFile.buffer, {
            width: 1200,
            height: 400,
            quality: 85,
            format: 'jpeg'
          })
          
          const coverKey = `covers/${userId}/${uuidv4()}.jpg`
          uploadedFiles.coverUrl = await uploadToS3(processedCover, coverKey, 'image/jpeg')
        }

        if (req.files.documents) {
          for (const doc of req.files.documents) {
            const docKey = `documents/${userId}/${uuidv4()}-${doc.originalname}`
            const docUrl = await uploadToS3(doc.buffer, docKey, doc.mimetype)
            uploadedFiles.documentUrls.push({
              url: docUrl,
              name: doc.originalname,
              size: doc.size,
              type: doc.mimetype
            })
          }
        }
      }

      let websiteData = null
      if (website) {
        try {
          websiteData = await scrapeWebsite(website)
        } catch (error) {
          logger.warn('Website scraping failed:', error)
        }
      }

      const updatedUser = await prisma.$transaction(async (tx) => {
        const userUpdate = await tx.user.update({
          where: { id: userId },
          data: {
            firstName: firstName || undefined,
            lastName: lastName || undefined,
            phoneNumber: phoneNumber || undefined,
            dateOfBirth: dateOfBirth ? new Date(dateOfBirth) : undefined,
            avatarUrl: uploadedFiles.avatarUrl || undefined,
            website: website || undefined
          }
        })

        const profileUpdate = await tx.profile.upsert({
          where: { userId },
          update: {
            bio: bio || undefined,
            location: location || undefined,
            coverImageUrl: uploadedFiles.coverUrl || undefined,
            socialLinks: parsedSocialLinks,
            skills: parsedSkills,
            interests: parsedInterests,
            websiteData: websiteData ? JSON.stringify(websiteData) : undefined,
            lastProfileUpdate: new Date()
          },
          create: {
            userId,
            bio: bio || '',
            location: location || '',
            coverImageUrl: uploadedFiles.coverUrl,
            socialLinks: parsedSocialLinks,
            skills: parsedSkills,
            interests: parsedInterests,
            websiteData: websiteData ? JSON.stringify(websiteData) : null,
            timezone: 'UTC',
            language: 'en',
            theme: 'light'
          }
        })

        if (Object.keys(parsedPrivacy).length > 0) {
          await tx.preferences.update({
            where: { userId },
            data: {
              privacy: {
                ...req.user.preferences?.privacy || {},
                ...parsedPrivacy
              }
            }
          })
        }

        if (uploadedFiles.documentUrls.length > 0) {
          for (const doc of uploadedFiles.documentUrls) {
            await tx.attachment.create({
              data: {
                userId,
                fileName: doc.name,
                fileUrl: doc.url,
                fileSize: doc.size,
                mimeType: doc.type,
                uploadDate: new Date()
              }
            })
          }
        }

        return { user: userUpdate, profile: profileUpdate }
      })

      const searchData = {
        userId,
        firstName: updatedUser.user.firstName,
        lastName: updatedUser.user.lastName,
        bio: updatedUser.profile.bio,
        skills: parsedSkills,
        interests: parsedInterests,
        location: updatedUser.profile.location,
        website: updatedUser.user.website
      }

      await redis.setex(`search:user:${userId}`, 24 * 60 * 60, JSON.stringify(searchData))

      await processAnalytics(userId, 'profile_update', {
        fieldsUpdated: Object.keys(req.body),
        hasAvatar: !!uploadedFiles.avatarUrl,
        hasCover: !!uploadedFiles.coverUrl,
        documentCount: uploadedFiles.documentUrls.length,
        skillsCount: parsedSkills.length,
        interestsCount: parsedInterests.length
      })

      await logActivity(userId, 'PROFILE_UPDATED', {
        fieldsUpdated: Object.keys(req.body),
        uploadedFiles: {
          avatar: !!uploadedFiles.avatarUrl,
          cover: !!uploadedFiles.coverUrl,
          documents: uploadedFiles.documentUrls.length
        },
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      })

      const majorFields = ['firstName', 'lastName', 'bio', 'avatar']
      const hasMajorUpdate = majorFields.some(field => req.body[field] !== undefined || uploadedFiles.avatarUrl)

      if (hasMajorUpdate) {
        const connections = await prisma.connection.findMany({
          where: { 
            OR: [
              { userId, status: 'accepted' },
              { connectedUserId: userId, status: 'accepted' }
            ]
          },
          include: {
            user: true,
            connectedUser: true
          }
        })

        for (const connection of connections) {
          const connectedUser = connection.userId === userId ? connection.connectedUser : connection.user
          
          if (connectedUser.preferences?.notifications?.profileUpdates) {
            if (rabbitmqChannel) {
              await rabbitmqChannel.sendToQueue(
                'notification_queue',
                Buffer.from(JSON.stringify({
                  type: 'profile_update',
                  userId: connectedUser.id,
                  data: {
                    updatedUserId: userId,
                    updatedUserName: `${updatedUser.user.firstName} ${updatedUser.user.lastName}`,
                    updateType: 'profile'
                  }
                })),
                { persistent: true }
              )
            }
          }
        }
      }

      await redis.setex(`user:${userId}`, 3600, JSON.stringify({
        id: userId,
        email: req.user.email,
        firstName: updatedUser.user.firstName,
        lastName: updatedUser.user.lastName,
        avatarUrl: updatedUser.user.avatarUrl,
        isActive: req.user.isActive,
        emailVerified: req.user.emailVerified,
        lastActivity: Date.now()
      }))

      res.json({
        success: true,
        message: 'Profile updated successfully',
        user: updatedUser.user,
        profile: updatedUser.profile,
        uploadedFiles: uploadedFiles.documentUrls.length > 0 ? uploadedFiles.documentUrls : undefined
      })

    } catch (error) {
      logger.error('Profile update error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Profile update failed' })
    }
  }
)

app.get('/api/users/:userId/analytics',
  strictRateLimit,
  authenticateJWT,
  [
    param('userId').isUUID(),
    body('dateRange').optional().isIn(['7d', '30d', '90d', '1y', 'all']),
    body('metrics').optional().isJSON(),
    body('exportFormat').optional().isIn(['json', 'csv', 'xlsx', 'pdf'])
  ],
  validateRequest,
  async (req, res) => {
    try {
      const { userId } = req.params
      const { 
        dateRange = '30d', 
        metrics = '["all"]', 
        exportFormat = null,
        includeRealTime = false
      } = req.query

      if (userId !== req.user.id && !req.user.permissions?.analytics?.viewOthers) {
        return res.status(403).json({ error: 'Insufficient permissions' })
      }

      const parsedMetrics = JSON.parse(metrics)
      
      const endDate = new Date()
      let startDate = new Date()
      
      switch (dateRange) {
        case '7d':
          startDate.setDate(endDate.getDate() - 7)
          break
        case '30d':
          startDate.setDate(endDate.getDate() - 30)
          break
        case '90d':
          startDate.setDate(endDate.getDate() - 90)
          break
        case '1y':
          startDate.setFullYear(endDate.getFullYear() - 1)
          break
        case 'all':
          startDate = new Date('2020-01-01')
          break
      }

      const analyticsData = {}

      if (includeRealTime) {
        const realtimeKeys = await redis.keys(`analytics:${userId}:*`)
        const realtimeData = {}
        
        for (const key of realtimeKeys) {
          const data = await redis.hgetall(key)
          const date = key.split(':')[2]
          realtimeData[date] = data
        }
        
        analyticsData.realtime = realtimeData
      }

      if (parsedMetrics.includes('all') || parsedMetrics.includes('overview')) {
        const userAnalytics = await prisma.userAnalytics.findUnique({
          where: { userId }
        })
        analyticsData.overview = userAnalytics
      }

      if (parsedMetrics.includes('all') || parsedMetrics.includes('activities')) {
        const activities = await prisma.activity.findMany({
          where: {
            userId,
            timestamp: {
              gte: startDate,
              lte: endDate
            }
          },
          orderBy: { timestamp: 'desc' },
          take: 1000
        })

        const activityStats = activities.reduce((acc, activity) => {
          const date = moment(activity.timestamp).format('YYYY-MM-DD')
          if (!acc[date]) acc[date] = {}
          if (!acc[date][activity.action]) acc[date][activity.action] = 0
          acc[date][activity.action]++
          return acc
        }, {})

        analyticsData.activities = {
          raw: activities,
          grouped: activityStats,
          total: activities.length
        }
      }

      if (parsedMetrics.includes('all') || parsedMetrics.includes('sessions')) {
        const sessions = await prisma.session.findMany({
          where: {
            userId,
            createdAt: {
              gte: startDate,
              lte: endDate
            }
          },
          orderBy: { createdAt: 'desc' }
        })

        const sessionStats = {
          total: sessions.length,
          byDevice: sessions.reduce((acc, session) => {
            const deviceType = session.userAgent?.includes('Mobile') ? 'mobile' : 'desktop'
            acc[deviceType] = (acc[deviceType] || 0) + 1
            return acc
          }, {}),
          byLocation: sessions.reduce((acc, session) => {
            const location = session.location || 'Unknown'
            acc[location] = (acc[location] || 0) + 1
            return acc
          }, {}),
          averageDuration: sessions.length > 0 
            ? sessions.reduce((sum, session) => {
                const duration = session.lastActivity 
                  ? new Date(session.lastActivity) - new Date(session.createdAt)
                  : 0
                return sum + duration
              }, 0) / sessions.length
            : 0
        }

        analyticsData.sessions = sessionStats
      }

      if (parsedMetrics.includes('all') || parsedMetrics.includes('events')) {
        try {
          const dynamoData = await dynamodb.query({
            TableName: 'UserAnalytics',
            KeyConditionExpression: 'userId = :userId',
            FilterExpression: '#timestamp BETWEEN :startDate AND :endDate',
            ExpressionAttributeNames: {
              '#timestamp': 'timestamp'
            },
            ExpressionAttributeValues: {
              ':userId': userId,
              ':startDate': startDate.getTime(),
              ':endDate': endDate.getTime()
            },
            ScanIndexForward: false,
            Limit: 10000
          }).promise()

          const events = dynamoData.Items || []
          const eventStats = events.reduce((acc, event) => {
            if (!acc[event.eventType]) acc[event.eventType] = 0
            acc[event.eventType]++
            return acc
          }, {})

          analyticsData.events = {
            total: events.length,
            byType: eventStats,
            raw: events.slice(0, 100) // Limit raw events
          }
        } catch (dynamoError) {
          logger.error('DynamoDB query error:', dynamoError)
          analyticsData.events = { error: 'Unable to fetch event data' }
        }
      }

      if (parsedMetrics.includes('all') || parsedMetrics.includes('payments')) {
        const transactions = await prisma.transaction.findMany({
          where: {
            userId,
            createdAt: {
              gte: startDate,
              lte: endDate
            }
          },
          orderBy: { createdAt: 'desc' }
        })

        const paymentStats = {
          totalTransactions: transactions.length,
          totalAmount: transactions.reduce((sum, t) => sum + t.amount, 0),
          successfulPayments: transactions.filter(t => t.status === 'completed').length,
          failedPayments: transactions.filter(t => t.status === 'failed').length,
          averageTransactionValue: transactions.length > 0 
            ? transactions.reduce((sum, t) => sum + t.amount, 0) / transactions.length
            : 0,
          monthlyRevenue: transactions
            .filter(t => t.status === 'completed')
            .reduce((acc, t) => {
              const month = moment(t.createdAt).format('YYYY-MM')
              acc[month] = (acc[month] || 0) + t.amount
              return acc
            }, {})
        }

        analyticsData.payments = paymentStats
      }

      const insights = []
      
      if (analyticsData.activities) {
        const recentActivities = Object.values(analyticsData.activities.grouped).slice(-7)
        const avgDailyActivity = recentActivities.reduce((sum, day) => 
          sum + Object.values(day).reduce((daySum, count) => daySum + count, 0), 0
        ) / recentActivities.length

        if (avgDailyActivity > 10) {
          insights.push({
            type: 'positive',
            title: 'High Activity',
            message: `You've been very active with an average of ${Math.round(avgDailyActivity)} actions per day.`
          })
        }
      }

      if (analyticsData.sessions) {
        if (analyticsData.sessions.total > 20) {
          insights.push({
            type: 'info',
            title: 'Frequent User',
            message: `You had ${analyticsData.sessions.total} login sessions in this period.`
          })
        }
      }

      analyticsData.insights = insights

      if (exportFormat) {
        let exportData = null
        let contentType = 'application/json'
        let filename = `analytics-${userId}-${dateRange}.json`

        switch (exportFormat) {
          case 'json':
            exportData = Buffer.from(JSON.stringify(analyticsData, null, 2))
            break

          case 'csv':
            if (analyticsData.activities) {
              const csvData = analyticsData.activities.raw.map(activity => ({
                date: moment(activity.timestamp).format('YYYY-MM-DD HH:mm:ss'),
                action: activity.action,
                details: JSON.stringify(activity.details),
                ipAddress: activity.ipAddress,
                location: activity.location
              }))

              const csvString = [
                Object.keys(csvData[0]).join(','),
                ...csvData.map(row => Object.values(row).map(val => 
                  typeof val === 'string' && val.includes(',') ? `"${val}"` : val
                ).join(','))
              ].join('\n')

              exportData = Buffer.from(csvString)
              contentType = 'text/csv'
              filename = `analytics-${userId}-${dateRange}.csv`
            }
            break

          case 'xlsx':
            const workbook = new ExcelJS.Workbook()
            
            if (analyticsData.activities) {
              const worksheet = workbook.addWorksheet('Activities')
              worksheet.columns = [
                { header: 'Date', key: 'date', width: 20 },
                { header: 'Action', key: 'action', width: 20 },
                { header: 'Details', key: 'details', width: 40 },
                { header: 'IP Address', key: 'ipAddress', width: 15 },
                { header: 'Location', key: 'location', width: 20 }
              ]

              analyticsData.activities.raw.forEach(activity => {
                worksheet.addRow({
                  date: moment(activity.timestamp).format('YYYY-MM-DD HH:mm:ss'),
                  action: activity.action,
                  details: JSON.stringify(activity.details),
                  ipAddress: activity.ipAddress,
                  location: activity.location
                })
              })
            }

            exportData = await workbook.xlsx.writeBuffer()
            contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            filename = `analytics-${userId}-${dateRange}.xlsx`
            break

          case 'pdf':
            exportData = await generatePDF({
              'User ID': userId,
              'Date Range': dateRange,
              'Total Activities': analyticsData.activities?.total || 0,
              'Total Sessions': analyticsData.sessions?.total || 0,
              'Total Events': analyticsData.events?.total || 0,
              'Generated At': new Date().toISOString()
            })
            contentType = 'application/pdf'
            filename = `analytics-${userId}-${dateRange}.pdf`
            break
        }

        if (exportData) {
          await prisma.export.create({
            data: {
              userId,
              type: 'analytics',
              format: exportFormat,
              filename,
              size: exportData.length,
              parameters: JSON.stringify({ dateRange, metrics: parsedMetrics }),
              createdAt: new Date()
            }
          })

          res.setHeader('Content-Type', contentType)
          res.setHeader('Content-Disposition', `attachment; filename=${filename}`)
          return res.send(exportData)
        }
      }

      await logActivity(userId, 'ANALYTICS_ACCESSED', {
        dateRange,
        metrics: parsedMetrics,
        exportFormat,
        accessedBy: req.user.id,
        ipAddress: req.ip
      })

      await processAnalytics(userId, 'analytics_view', {
        dateRange,
        metricsRequested: parsedMetrics,
        exportRequested: !!exportFormat
      })

      res.json({
        success: true,
        data: analyticsData,
        meta: {
          dateRange: {
            start: startDate.toISOString(),
            end: endDate.toISOString()
          },
          metrics: parsedMetrics,
          generatedAt: new Date().toISOString()
        }
      })

    } catch (error) {
      logger.error('Analytics fetch error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Analytics fetch failed' })
    }
  }
)

app.post('/api/users/import',
  uploadRateLimit,
  authenticateJWT,
  upload.single('file'),
  [
    body('importType').isIn(['contacts', 'transactions', 'activities', 'products', 'users']),
    body('mapping').optional().isJSON(),
    body('options').optional().isJSON()
  ],
  validateRequest,
  async (req, res) => {
    try {
      const { importType, mapping = '{}', options = '{}' } = req.body
      const userId = req.user.id
      
      if (!req.file) {
        return res.status(400).json({ error: 'File is required' })
      }

      const parsedMapping = JSON.parse(mapping)
      const parsedOptions = JSON.parse(options)
      const importId = uuidv4()

      const importJob = await prisma.import.create({
        data: {
          id: importId,
          userId,
          type: importType,
          filename: req.file.originalname,
          fileSize: req.file.size,
          status: 'processing',
          mapping: parsedMapping,
          options: parsedOptions,
          createdAt: new Date()
        }
      })

      let processedData = []
      const fileExtension = path.extname(req.file.originalname).toLowerCase()

      try {
        switch (fileExtension) {
          case '.csv':
            processedData = await processCSV(req.file.buffer)
            break
          case '.xlsx':
          case '.xls':
            processedData = await processExcel(req.file.buffer)
            break
          case '.json':
            processedData = JSON.parse(req.file.buffer.toString())
            break
          default:
            throw new Error('Unsupported file format')
        }

        const validatedData = []
        const errors = []

        for (let i = 0; i < processedData.length; i++) {
          const row = processedData[i]
          
          try {
            let transformedRow = {}

            switch (importType) {
              case 'contacts':
                transformedRow = {
                  firstName: row[parsedMapping.firstName || 'firstName'] || row.firstName,
                  lastName: row[parsedMapping.lastName || 'lastName'] || row.lastName,
                  email: row[parsedMapping.email || 'email'] || row.email,
                  phoneNumber: row[parsedMapping.phoneNumber || 'phoneNumber'] || row.phoneNumber,
                  company: row[parsedMapping.company || 'company'] || row.company,
                  notes: row[parsedMapping.notes || 'notes'] || row.notes,
                  tags: row[parsedMapping.tags || 'tags'] ? 
                    (typeof row[parsedMapping.tags] === 'string' ? 
                      row[parsedMapping.tags].split(',').map(t => t.trim()) : 
                      row[parsedMapping.tags]) : []
                }

                if (transformedRow.email && !validator.isEmail(transformedRow.email)) {
                  errors.push({ row: i + 1, field: 'email', message: 'Invalid email format' })
                  continue
                }

                if (transformedRow.phoneNumber && !validator.isMobilePhone(transformedRow.phoneNumber)) {
                  errors.push({ row: i + 1, field: 'phoneNumber', message: 'Invalid phone format' })
                  continue
                }
                break

              case 'transactions':
                transformedRow = {
                  amount: parseFloat(row[parsedMapping.amount || 'amount'] || row.amount),
                  currency: row[parsedMapping.currency || 'currency'] || row.currency || 'USD',
                  description: row[parsedMapping.description || 'description'] || row.description,
                  category: row[parsedMapping.category || 'category'] || row.category,
                  date: new Date(row[parsedMapping.date || 'date'] || row.date),
                  reference: row[parsedMapping.reference || 'reference'] || row.reference,
                  status: row[parsedMapping.status || 'status'] || row.status || 'completed'
                }

                if (isNaN(transformedRow.amount)) {
                  errors.push({ row: i + 1, field: 'amount', message: 'Invalid amount' })
                  continue
                }

                if (isNaN(transformedRow.date.getTime())) {
                  errors.push({ row: i + 1, field: 'date', message: 'Invalid date' })
                  continue
                }
                break

              case 'products':
                transformedRow = {
                  name: row[parsedMapping.name || 'name'] || row.name,
                  description: row[parsedMapping.description || 'description'] || row.description,
                  price: parseFloat(row[parsedMapping.price || 'price'] || row.price),
                  category: row[parsedMapping.category || 'category'] || row.category,
                  sku: row[parsedMapping.sku || 'sku'] || row.sku,
                  stock: parseInt(row[parsedMapping.stock || 'stock'] || row.stock) || 0,
                  status: row[parsedMapping.status || 'status'] || row.status || 'active'
                }

                if (!transformedRow.name) {
                  errors.push({ row: i + 1, field: 'name', message: 'Name is required' })
                  continue
                }

                if (isNaN(transformedRow.price)) {
                  errors.push({ row: i + 1, field: 'price', message: 'Invalid price' })
                  continue
                }
                break

              default:
                transformedRow = row
            }

            validatedData.push(transformedRow)

          } catch (rowError) {
            errors.push({ row: i + 1, message: rowError.message })
          }
        }

        let importResults = {
          success: 0,
          failed: 0,
          skipped: 0
        }

        if (validatedData.length > 0 && errors.length < processedData.length * 0.5) {
          
          for (const item of validatedData) {
            try {
              switch (importType) {
                case 'contacts':
                  const existingContact = await prisma.contact.findFirst({
                    where: {
                      userId,
                      email: item.email
                    }
                  })

                  if (existingContact && !parsedOptions.allowDuplicates) {
                    importResults.skipped++
                    continue
                  }

                  await prisma.contact.create({
                    data: {
                      userId,
                      ...item,
                      importId
                    }
                  })
                  break

                case 'transactions':
                  await prisma.transaction.create({
                    data: {
                      userId,
                      ...item,
                      importId
                    }
                  })
                  break

                case 'products':
                  await prisma.product.create({
                    data: {
                      userId,
                      ...item,
                      importId
                    }
                  })
                  break
              }

              importResults.success++

            } catch (dbError) {
              logger.error('Import item error:', dbError)
              importResults.failed++
            }
          }
        }

        await prisma.import.update({
          where: { id: importId },
          data: {
            status: errors.length > 0 ? 'completed_with_errors' : 'completed',
            processedRows: processedData.length,
            successfulRows: importResults.success,
            failedRows: importResults.failed + errors.length,
            skippedRows: importResults.skipped,
            errors: JSON.stringify(errors),
            completedAt: new Date()
          }
        })

        const emailHtml = `
          <h2>Import Completed</h2>
          <p>Your ${importType} import has been completed.</p>
          <p><strong>File:</strong> ${req.file.originalname}</p>
          <p><strong>Total Rows:</strong> ${processedData.length}</p>
          <p><strong>Successful:</strong> ${importResults.success}</p>
          <p><strong>Failed:</strong> ${importResults.failed + errors.length}</p>
          <p><strong>Skipped:</strong> ${importResults.skipped}</p>
          ${errors.length > 0 ? `<p><strong>Errors:</strong> ${errors.length} validation errors found</p>` : ''}
          <p>You can view the detailed results in your dashboard.</p>
        `

        if (rabbitmqChannel) {
          await rabbitmqChannel.sendToQueue(
            'email_queue',
            Buffer.from(JSON.stringify({
              to: req.user.email,
              subject: `Import Completed - ${importType}`,
              html: emailHtml,
              priority: 'normal'
            })),
            { persistent: true }
          )
        }

        await logActivity(userId, 'DATA_IMPORTED', {
          importId,
          type: importType,
          filename: req.file.originalname,
          totalRows: processedData.length,
          successfulRows: importResults.success,
          failedRows: importResults.failed + errors.length,
          errors: errors.length,
          ipAddress: req.ip
        })

        await processAnalytics(userId, 'data_import', {
          type: importType,
          fileSize: req.file.size,
          rowsProcessed: processedData.length,
          successRate: (importResults.success / processedData.length) * 100
        })

        res.json({
          success: true,
          message: 'Import completed',
          importId,
          results: {
            totalRows: processedData.length,
            successful: importResults.success,
            failed: importResults.failed + errors.length,
            skipped: importResults.skipped,
            errors: errors.slice(0, 10), // Return first 10 errors
            hasMoreErrors: errors.length > 10
          }
        })

      } catch (processingError) {
        await prisma.import.update({
          where: { id: importId },
          data: {
            status: 'failed',
            errors: JSON.stringify([{ message: processingError.message }]),
            completedAt: new Date()
          }
        })

        throw processingError
      }

    } catch (error) {
      logger.error('Import error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Import failed', details: error.message })
    }
  }
)

app.post('/api/notifications/send',
  strictRateLimit,
  authenticateJWT,
  [
    body('recipients').isArray().notEmpty(),
    body('type').isIn(['email', 'push', 'sms', 'in_app', 'webhook']),
    body('title').trim().isLength({ min: 1, max: 200 }),
    body('message').trim().isLength({ min: 1, max: 1000 }),
    body('priority').optional().isIn(['low', 'normal', 'high', 'urgent']),
    body('scheduledFor').optional().isISO8601(),
    body('data').optional().isJSON()
  ],
  validateRequest,
  async (req, res) => {
    try {
      const {
        recipients,
        type,
        title,
        message,
        priority = 'normal',
        scheduledFor = null,
        data = '{}',
        templateId = null,
        personalization = '{}'
      } = req.body

      const senderId = req.user.id
      const parsedData = JSON.parse(data)
      const parsedPersonalization = JSON.parse(personalization)
      const notificationId = uuidv4()

      if (type === 'sms' && !req.user.permissions?.notifications?.sms) {
        return res.status(403).json({ error: 'SMS permissions required' })
      }

      if (recipients.length > 1000 && !req.user.permissions?.notifications?.bulk) {
        return res.status(403).json({ error: 'Bulk notification permissions required' })
      }

      const validRecipients = []
      for (const recipient of recipients) {
        if (typeof recipient === 'string') {
          if (validator.isEmail(recipient)) {
            validRecipients.push({ type: 'email', value: recipient })
          } else if (validator.isMobilePhone(recipient)) {
            validRecipients.push({ type: 'phone', value: recipient })
          }
        } else if (typeof recipient === 'object' && recipient.userId) {
          const user = await userLoader.load(recipient.userId)
          if (user) {
            validRecipients.push({ 
              type: 'user', 
              userId: user.id,
              email: user.email,
              phoneNumber: user.phoneNumber,
              preferences: user.preferences
            })
          }
        }
      }

      if (validRecipients.length === 0) {
        return res.status(400).json({ error: 'No valid recipients found' })
      }

      const notification = await prisma.notification.create({
        data: {
          id: notificationId,
          senderId,
          type,
          title,
          message,
          priority,
          scheduledFor: scheduledFor ? new Date(scheduledFor) : null,
          data: parsedData,
          templateId,
          status: scheduledFor ? 'scheduled' : 'sending',
          recipientCount: validRecipients.length,
          createdAt: new Date()
        }
      })

      const results = {
        sent: 0,
        failed: 0,
        scheduled: 0,
        errors: []
      }

      for (const recipient of validRecipients) {
        try {
          let personalizedTitle = title
          let personalizedMessage = message

          if (recipient.type === 'user' && Object.keys(parsedPersonalization).length > 0) {
            const user = await userLoader.load(recipient.userId)
            personalizedTitle = title.replace(/\{\{(\w+)\}\}/g, (match, key) => 
              user[key] || parsedPersonalization[key] || match
            )
            personalizedMessage = message.replace(/\{\{(\w+)\}\}/g, (match, key) => 
              user[key] || parsedPersonalization[key] || match
            )
          }

          const recipientRecord = await prisma.notificationRecipient.create({
            data: {
              notificationId,
              recipientType: recipient.type,
              recipientId: recipient.userId || null,
              email: recipient.email || recipient.value,
              phoneNumber: recipient.phoneNumber || (recipient.type === 'phone' ? recipient.value : null),
              status: scheduledFor ? 'scheduled' : 'pending'
            }
          })

          if (scheduledFor) {
            results.scheduled++
            continue
          }

          switch (type) {
            case 'email':
              const emailRecipient = recipient.email || recipient.value
              await sendEmail(emailRecipient, personalizedTitle, personalizedMessage)
              
              await prisma.notificationRecipient.update({
                where: { id: recipientRecord.id },
                data: { status: 'sent', sentAt: new Date() }
              })
              results.sent++
              break

            case 'push':
              if (recipient.type === 'user') {
                const pushSubscriptions = await prisma.pushSubscription.findMany({
                  where: { userId: recipient.userId, active: true }
                })

                for (const subscription of pushSubscriptions) {
                  await sendPushNotification(JSON.parse(subscription.subscription), {
                    title: personalizedTitle,
                    body: personalizedMessage,
                    icon: '/icon-192x192.png',
                    data: parsedData
                  })
                }

                await prisma.notificationRecipient.update({
                  where: { id: recipientRecord.id },
                  data: { status: 'sent', sentAt: new Date() }
                })
                results.sent++
              }
              break

            case 'sms':
              const phoneRecipient = recipient.phoneNumber || recipient.value
              await twilio.messages.create({
                body: `${personalizedTitle}\n\n${personalizedMessage}`,
                from: process.env.TWILIO_PHONE_NUMBER,
                to: phoneRecipient
              })

              await prisma.notificationRecipient.update({
                where: { id: recipientRecord.id },
                data: { status: 'sent', sentAt: new Date() }
              })
              results.sent++
              break

            case 'in_app':
              if (recipient.type === 'user') {
                await prisma.userNotification.create({
                  data: {
                    userId: recipient.userId,
                    title: personalizedTitle,
                    message: personalizedMessage,
                    type: 'info',
                    priority,
                    data: parsedData,
                    read: false
                  }
                })

                const io = req.app.get('io')
                if (io) {
                  io.to(`user:${recipient.userId}`).emit('notification', {
                    id: notificationId,
                    title: personalizedTitle,
                    message: personalizedMessage,
                    type: 'info',
                    priority,
                    data: parsedData,
                    timestamp: new Date().toISOString()
                  })
                }

                await prisma.notificationRecipient.update({
                  where: { id: recipientRecord.id },
                  data: { status: 'sent', sentAt: new Date() }
                })
                results.sent++
              }
              break

            case 'webhook':
              if (recipient.webhookUrl) {
                const webhookPayload = {
                  id: notificationId,
                  title: personalizedTitle,
                  message: personalizedMessage,
                  priority,
                  data: parsedData,
                  timestamp: new Date().toISOString(),
                  recipient: recipient.userId || recipient.value
                }

                await axios.post(recipient.webhookUrl, webhookPayload, {
                  timeout: 10000,
                  headers: {
                    'Content-Type': 'application/json',
                    'X-Notification-ID': notificationId,
                    'X-Sender-ID': senderId
                  }
                })

                await prisma.notificationRecipient.update({
                  where: { id: recipientRecord.id },
                  data: { status: 'sent', sentAt: new Date() }
                })
                results.sent++
              }
              break
          }

        } catch (recipientError) {
          logger.error('Notification send error:', recipientError)
          results.failed++
          results.errors.push({
            recipient: recipient.email || recipient.userId || recipient.value,
            error: recipientError.message
          })

          await prisma.notificationRecipient.update({
            where: { id: recipientRecord.id },
            data: { 
              status: 'failed', 
              error: recipientError.message,
              failedAt: new Date()
            }
          })
        }
      }

      const finalStatus = results.failed > 0 
        ? (results.sent > 0 ? 'partially_sent' : 'failed')
        : (results.scheduled > 0 ? 'scheduled' : 'sent')

      await prisma.notification.update({
        where: { id: notificationId },
        data: {
          status: finalStatus,
          sentCount: results.sent,
          failedCount: results.failed,
          scheduledCount: results.scheduled,
          completedAt: new Date()
        }
      })

      await logActivity(senderId, 'NOTIFICATION_SENT', {
        notificationId,
        type,
        recipientCount: validRecipients.length,
        sent: results.sent,
        failed: results.failed,
        scheduled: results.scheduled,
        ipAddress: req.ip
      })

      await processAnalytics(senderId, 'notification_sent', {
        type,
        recipientCount: validRecipients.length,
        priority,
        successRate: (results.sent / validRecipients.length) * 100
      })

      res.json({
        success: true,
        message: 'Notification processing completed',
        notificationId,
        results: {
          sent: results.sent,
          failed: results.failed,
          scheduled: results.scheduled,
          errors: results.errors.slice(0, 10) // Return first 10 errors
        }
      })

    } catch (error) {
      logger.error('Notification error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Notification failed' })
    }
  }
)

app.post('/api/payments/process',
  strictRateLimit,
  authenticateJWT,
  [
    body('amount').isFloat({ min: 0.01 }),
    body('currency').isIn(['USD', 'EUR', 'GBP', 'CAD', 'AUD']),
    body('paymentMethodId').notEmpty(),
    body('description').trim().isLength({ min: 1, max: 500 }),
    body('metadata').optional().isJSON(),
    body('subscriptionPlan').optional().isIn(['basic', 'pro', 'enterprise']),
    body('billingCycle').optional().isIn(['monthly', 'yearly'])
  ],
  validateRequest,
  async (req, res) => {
    try {
      const {
        amount,
        currency,
        paymentMethodId,
        description,
        metadata = '{}',
        subscriptionPlan = null,
        billingCycle = 'monthly',
        couponCode = null
      } = req.body

      const userId = req.user.id
      const parsedMetadata = JSON.parse(metadata)
      
      let stripeCustomerId = req.user.stripeCustomerId
      
      if (!stripeCustomerId) {
        const stripeCustomer = await stripe.customers.create({
          email: req.user.email,
          name: `${req.user.firstName} ${req.user.lastName}`,
          metadata: { userId }
        })
        
        stripeCustomerId = stripeCustomer.id
        
        await prisma.user.update({
          where: { id: userId },
          data: { stripeCustomerId }
        })
      }

      let finalAmount = amount
      let appliedCoupon = null

      if (couponCode) {
        try {
          const coupon = await stripe.coupons.retrieve(couponCode)
          if (coupon.valid) {
            if (coupon.amount_off) {
              finalAmount = Math.max(0.01, amount - (coupon.amount_off / 100))
            } else if (coupon.percent_off) {
              finalAmount = amount * (1 - coupon.percent_off / 100)
            }
            appliedCoupon = coupon
          }
        } catch (couponError) {
          logger.warn('Invalid coupon code:', couponError)
        }
      }

      const paymentIntentData = {
        amount: Math.round(finalAmount * 100), // Convert to cents
        currency,
        customer: stripeCustomerId,
        payment_method: paymentMethodId,
        description,
        metadata: {
          userId,
          ...parsedMetadata
        },
        confirm: true,
        automatic_payment_methods: { enabled: true, allow_redirects: 'never' }
      }

      if (appliedCoupon) {
        paymentIntentData.metadata.couponCode = couponCode
        paymentIntentData.metadata.discount = (amount - finalAmount).toString()
      }

      const paymentIntent = await stripe.paymentIntents.create(paymentIntentData)

      const transaction = await prisma.transaction.create({
        data: {
          userId,
          stripePaymentIntentId: paymentIntent.id,
          amount: finalAmount,
          currency,
          description,
          status: paymentIntent.status === 'succeeded' ? 'completed' : 'pending',
          paymentMethod: 'stripe',
          metadata: {
            ...parsedMetadata,
            couponCode,
            originalAmount: amount,
            discount: appliedCoupon ? amount - finalAmount : 0
          },
          createdAt: new Date()
        }
      })

      let subscription = null
      if (subscriptionPlan && paymentIntent.status === 'succeeded') {
        try {
          const subscriptionConfig = {
            basic: {
              price: billingCycle === 'yearly' ? 99.99 : 9.99,
              features: {
                maxStorage: '10GB',
                maxApiCalls: 10000,
                supportLevel: 'standard',
                customBranding: false
              }
            },
            pro: {
              price: billingCycle === 'yearly' ? 299.99 : 29.99,
              features: {
                maxStorage: '100GB',
                maxApiCalls: 100000,
                supportLevel: 'priority',
                customBranding: true,
                advancedAnalytics: true
              }
            },
            enterprise: {
              price: billingCycle === 'yearly' ? 999.99 : 99.99,
              features: {
                maxStorage: '1TB',
                maxApiCalls: 1000000,
                supportLevel: 'dedicated',
                customBranding: true,
                advancedAnalytics: true,
                apiAccess: true,
                whiteLabel: true
              }
            }
          }

          const config = subscriptionConfig[subscriptionPlan]
          if (config) {
            const existingSubscription = await prisma.subscription.findFirst({
              where: { userId, status: 'active' }
            })

            if (existingSubscription) {
              await prisma.subscription.update({
                where: { id: existingSubscription.id },
                data: { 
                  status: 'cancelled',
                  cancelledAt: new Date(),
                  cancelReason: 'upgraded'
                }
              })
            }

            const endDate = new Date()
            if (billingCycle === 'yearly') {
              endDate.setFullYear(endDate.getFullYear() + 1)
            } else {
              endDate.setMonth(endDate.getMonth() + 1)
            }

            subscription = await prisma.subscription.create({
              data: {
                userId,
                plan: subscriptionPlan,
                status: 'active',
                billingCycle,
                amount: config.price,
                currency,
                startDate: new Date(),
                endDate,
                features: JSON.stringify(config.features),
                transactionId: transaction.id
              }
            })

            await prisma.user.update({
              where: { id: userId },
              data: {
                subscriptionPlan,
                subscriptionStatus: 'active'
              }
            })

            const welcomeHtml = `
              <h1>Welcome to ${subscriptionPlan.charAt(0).toUpperCase() + subscriptionPlan.slice(1)}!</h1>
              <p>Your subscription has been activated successfully.</p>
              <h3>Your Plan Includes:</h3>
              <ul>
                ${Object.entries(config.features).map(([key, value]) => 
                  `<li><strong>${key}:</strong> ${value}</li>`
                ).join('')}
              </ul>
              <p><strong>Billing Cycle:</strong> ${billingCycle}</p>
              <p><strong>Next Billing Date:</strong> ${endDate.toLocaleDateString()}</p>
              <p>Thank you for choosing our service!</p>
            `

            if (rabbitmqChannel) {
              await rabbitmqChannel.sendToQueue(
                'email_queue',
                Buffer.from(JSON.stringify({
                  to: req.user.email,
                  subject: `Welcome to ${subscriptionPlan} Plan!`,
                  html: welcomeHtml,
                  priority: 'high'
                })),
                { persistent: true }
              )
            }
          }
        } catch (subscriptionError) {
          logger.error('Subscription creation error:', subscriptionError)
        }
      }

      if (paymentIntent.status === 'succeeded') {
        const confirmationHtml = `
          <h1>Payment Confirmation</h1>
          <p>Your payment has been processed successfully.</p>
          <p><strong>Amount:</strong> ${currency} ${finalAmount.toFixed(2)}</p>
          <p><strong>Description:</strong> ${description}</p>
          <p><strong>Transaction ID:</strong> ${transaction.id}</p>
          <p><strong>Date:</strong> ${new Date().toLocaleDateString()}</p>
          ${appliedCoupon ? `<p><strong>Discount Applied:</strong> ${couponCode} - ${currency} ${(amount - finalAmount).toFixed(2)}</p>` : ''}
          <p>Thank you for your payment!</p>
        `

        if (rabbitmqChannel) {
          await rabbitmqChannel.sendToQueue(
            'email_queue',
            Buffer.from(JSON.stringify({
              to: req.user.email,
              subject: 'Payment Confirmation',
              html: confirmationHtml,
              priority: 'high'
            })),
            { persistent: true }
          )
        }

        if (req.user.phoneNumber && req.user.preferences?.notifications?.sms) {
          try {
            await twilio.messages.create({
              body: `Payment confirmed: ${currency} ${finalAmount.toFixed(2)} for ${description}. Transaction ID: ${transaction.id}`,
              from: process.env.TWILIO_PHONE_NUMBER,
              to: req.user.phoneNumber
            })
          } catch (smsError) {
            logger.error('SMS confirmation error:', smsError)
          }
        }

        await processAnalytics(userId, 'payment_successful', {
          amount: finalAmount,
          currency,
          subscriptionPlan,
          billingCycle,
          couponUsed: !!appliedCoupon,
          discount: appliedCoupon ? amount - finalAmount : 0
        })

        await prisma.userAnalytics.update({
          where: { userId },
          data: {
            totalSpent: { increment: finalAmount },
            totalTransactions: { increment: 1 },
            lastPurchaseDate: new Date()
          }
        })
      }

      await logActivity(userId, 'PAYMENT_PROCESSED', {
        transactionId: transaction.id,
        amount: finalAmount,
        currency,
        status: paymentIntent.status,
        subscriptionPlan,
        couponCode,
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      })

      res.json({
        success: paymentIntent.status === 'succeeded',
        message: paymentIntent.status === 'succeeded' ? 'Payment successful' : 'Payment requires additional action',
        paymentIntent: {
          id: paymentIntent.id,
          status: paymentIntent.status,
          amount: finalAmount,
          currency,
          clientSecret: paymentIntent.client_secret
        },
        transaction: {
          id: transaction.id,
          status: transaction.status
        },
        subscription: subscription ? {
          id: subscription.id,
          plan: subscription.plan,
          status: subscription.status,
          endDate: subscription.endDate
        } : null,
        appliedDiscount: appliedCoupon ? {
          code: couponCode,
          amount: amount - finalAmount
        } : null
      })

    } catch (error) {
      logger.error('Payment processing error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Payment processing failed', details: error.message })
    }
  }
)

app.post('/api/webhooks/:service',
  express.raw({ type: 'application/json' }),
  async (req, res) => {
    try {
      const { service } = req.params
      const signature = req.headers['stripe-signature'] || req.headers['x-hub-signature-256']
      
      let event
      let isValid = false

      switch (service) {
        case 'stripe':
          try {
            event = stripe.webhooks.constructEvent(req.body, signature, process.env.STRIPE_WEBHOOK_SECRET)
            isValid = true
          } catch (err) {
            logger.error('Stripe webhook signature verification failed:', err)
            return res.status(400).send(`Webhook signature verification failed: ${err.message}`)
          }
          break

        case 'github':
          const githubSignature = req.headers['x-hub-signature-256']
          const githubSecret = process.env.GITHUB_WEBHOOK_SECRET
          
          if (githubSignature && githubSecret) {
            const expectedSignature = 'sha256=' + crypto
              .createHmac('sha256', githubSecret)
              .update(req.body)
              .digest('hex')
            
            isValid = crypto.timingSafeEqual(
              Buffer.from(githubSignature),
              Buffer.from(expectedSignature)
            )
          }
          
          if (isValid) {
            event = JSON.parse(req.body)
            event.type = req.headers['x-github-event']
          }
          break

        case 'twilio':
          const twilioSignature = req.headers['x-twilio-signature']
          const twilioAuthToken = process.env.TWILIO_AUTH_TOKEN
          const url = `${req.protocol}://${req.get('host')}${req.originalUrl}`
          
          const twilioSignatureValid = twilio.validateRequest(
            twilioAuthToken,
            twilioSignature,
            url,
            req.body
          )
          
          if (twilioSignatureValid) {
            event = req.body
            event.type = 'sms_status'
            isValid = true
          }
          break

        default:
          return res.status(400).json({ error: 'Unknown webhook service' })
      }

      if (!isValid) {
        return res.status(401).json({ error: 'Webhook signature verification failed' })
      }

      switch (service) {
        case 'stripe':
          await handleStripeWebhook(event)
          break
        case 'github':
          await handleGitHubWebhook(event)
          break
        case 'twilio':
          await handleTwilioWebhook(event)
          break
      }

      await logActivity(null, 'WEBHOOK_RECEIVED', {
        service,
        eventType: event.type,
        eventId: event.id || event.delivery_id || 'unknown',
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      })

      res.json({ success: true, message: 'Webhook processed successfully' })

    } catch (error) {
      logger.error('Webhook processing error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Webhook processing failed' })
    }
  }
)

const handleStripeWebhook = async (event) => {
  switch (event.type) {
    case 'payment_intent.succeeded':
      const paymentIntent = event.data.object
      const userId = paymentIntent.metadata.userId
      
      await prisma.transaction.updateMany({
        where: { stripePaymentIntentId: paymentIntent.id },
        data: { 
          status: 'completed',
          completedAt: new Date()
        }
      })

      if (userId) {
        await processAnalytics(userId, 'payment_confirmed', {
          amount: paymentIntent.amount / 100,
          currency: paymentIntent.currency
        })
      }
      break

    case 'payment_intent.payment_failed':
      const failedPayment = event.data.object
      const failedUserId = failedPayment.metadata.userId
      
      await prisma.transaction.updateMany({
        where: { stripePaymentIntentId: failedPayment.id },
        data: { 
          status: 'failed',
          failedAt: new Date(),
          failureReason: failedPayment.last_payment_error?.message
        }
      })

      if (failedUserId) {
        const user = await userLoader.load(failedUserId)
        if (user) {
          const failureHtml = `
            <h1>Payment Failed</h1>
            <p>We were unable to process your payment.</p>
            <p><strong>Amount:</strong> ${failedPayment.currency.toUpperCase()} ${(failedPayment.amount / 100).toFixed(2)}</p>
            <p><strong>Reason:</strong> ${failedPayment.last_payment_error?.message || 'Unknown error'}</p>
            <p>Please try again or contact support if the problem persists.</p>
          `

          if (rabbitmqChannel) {
            await rabbitmqChannel.sendToQueue(
              'email_queue',
              Buffer.from(JSON.stringify({
                to: user.email,
                subject: 'Payment Failed',
                html: failureHtml,
                priority: 'high'
              })),
              { persistent: true }
            )
          }
        }

        await processAnalytics(failedUserId, 'payment_failed', {
          amount: failedPayment.amount / 100,
          currency: failedPayment.currency,
          reason: failedPayment.last_payment_error?.message
        })
      }
      break

    case 'customer.subscription.created':
    case 'customer.subscription.updated':
      const subscription = event.data.object
      const customerId = subscription.customer
      
      const user = await prisma.user.findFirst({
        where: { stripeCustomerId: customerId }
      })
      
      if (user) {
        const subscriptionStatus = subscription.status === 'active' ? 'active' : 
                                 subscription.status === 'canceled' ? 'cancelled' : 
                                 subscription.status

        await prisma.subscription.upsert({
          where: { stripeSubscriptionId: subscription.id },
          update: {
            status: subscriptionStatus,
            currentPeriodStart: new Date(subscription.current_period_start * 1000),
            currentPeriodEnd: new Date(subscription.current_period_end * 1000)
          },
          create: {
            userId: user.id,
            stripeSubscriptionId: subscription.id,
            plan: subscription.items.data[0]?.price?.nickname || 'unknown',
            status: subscriptionStatus,
            amount: subscription.items.data[0]?.price?.unit_amount / 100,
            currency: subscription.currency,
            startDate: new Date(subscription.start_date * 1000),
            currentPeriodStart: new Date(subscription.current_period_start * 1000),
            currentPeriodEnd: new Date(subscription.current_period_end * 1000)
          }
        })

        await processAnalytics(user.id, 'subscription_updated', {
          status: subscriptionStatus,
          plan: subscription.items.data[0]?.price?.nickname
        })
      }
      break

    case 'invoice.payment_succeeded':
      const invoice = event.data.object
      const invoiceCustomerId = invoice.customer
      
      const invoiceUser = await prisma.user.findFirst({
        where: { stripeCustomerId: invoiceCustomerId }
      })
      
      if (invoiceUser) {
        await processAnalytics(invoiceUser.id, 'invoice_paid', {
          amount: invoice.amount_paid / 100,
          currency: invoice.currency
        })
      }
      break
  }
}

const handleGitHubWebhook = async (event) => {
  switch (event.type) {
    case 'push':
      const repository = event.repository
      const pusher = event.pusher
      
      const user = await prisma.user.findFirst({
        where: {
          socialAccounts: {
            some: {
              provider: 'github',
              providerUserId: pusher.name
            }
          }
        }
      })

      if (user) {
        await logActivity(user.id, 'CODE_PUSHED', {
          repository: repository.full_name,
          commits: event.commits?.length || 0,
          ref: event.ref,
          pusher: pusher.name
        })

        await processAnalytics(user.id, 'github_push', {
          repository: repository.name,
          commits: event.commits?.length || 0,
          language: repository.language
        })
      }
      break

    case 'issues':
      if (event.action === 'opened') {
        const issueUser = await prisma.user.findFirst({
          where: {
            socialAccounts: {
              some: {
                provider: 'github',
                providerUserId: event.issue.user.login
              }
            }
          }
        })

        if (issueUser) {
          await processAnalytics(issueUser.id, 'github_issue_created', {
            repository: event.repository.name,
            issueTitle: event.issue.title
          })
        }
      }
      break
  }
}

const handleTwilioWebhook = async (event) => {
  const messageStatus = event.MessageStatus || event.SmsStatus
  const messageSid = event.MessageSid || event.SmsSid
  
  if (messageStatus && messageSid) {
    await prisma.smsLog.updateMany({
      where: { twilioMessageSid: messageSid },
      data: { 
        status: messageStatus,
        updatedAt: new Date()
      }
    })

    if (messageStatus === 'failed' || messageStatus === 'undelivered') {
      const smsLog = await prisma.smsLog.findFirst({
        where: { twilioMessageSid: messageSid }
      })
      
      if (smsLog) {
        await processAnalytics(smsLog.userId, 'sms_delivery_failed', {
          reason: event.ErrorMessage || 'Unknown error'
        })
      }
    }
  }
}

app.get('/api/search',
  strictRateLimit,
  authenticateJWT,
  [
    body('query').optional().trim().isLength({ max: 200 }),
    body('type').optional().isIn(['users', 'content', 'products', 'transactions', 'all']),
    body('filters').optional().isJSON(),
    body('sort').optional().isIn(['relevance', 'date', 'name', 'popularity']),
    body('page').optional().isInt({ min: 1 }),
    body('limit').optional().isInt({ min: 1, max: 100 })
  ],
  validateRequest,
  async (req, res) => {
    try {
      const {
        query = '',
        type = 'all',
        filters = '{}',
        sort = 'relevance',
        page = 1,
        limit = 20,
        facets = false
      } = req.query

      const parsedFilters = JSON.parse(filters)
      const offset = (parseInt(page) - 1) * parseInt(limit)
      const userId = req.user.id

      const searchResults = {
        query,
        results: [],
        facets: {},
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total: 0,
          totalPages: 0
        },
        executionTime: Date.now()
      }

      const searchConditions = []
      
      if (query) {
        const searchTerms = query.split(' ').filter(term => term.length > 0)
        searchConditions.push(...searchTerms)
      }

      if (type === 'all' || type === 'users') {
        const userSearchWhere = {
          AND: [
            {
              OR: searchConditions.length > 0 ? [
                { firstName: { contains: query, mode: 'insensitive' } },
                { lastName: { contains: query, mode: 'insensitive' } },
                { email: { contains: query, mode: 'insensitive' } },
                { profile: { bio: { contains: query, mode: 'insensitive' } } }
              ] : [{}]
            },
            { isActive: true },
            { emailVerified: true }
          ]
        }

        if (parsedFilters.location) {
          userSearchWhere.AND.push({
            profile: { location: { contains: parsedFilters.location, mode: 'insensitive' } }
          })
        }

        if (parsedFilters.skills) {
          userSearchWhere.AND.push({
            profile: { skills: { hasSome: parsedFilters.skills } }
          })
        }

        if (parsedFilters.dateRange) {
          const startDate = new Date(parsedFilters.dateRange.start)
          const endDate = new Date(parsedFilters.dateRange.end)
          userSearchWhere.AND.push({
            createdAt: { gte: startDate, lte: endDate }
          })
        }

        const users = await prisma.user.findMany({
          where: userSearchWhere,
          include: {
            profile: true,
            analytics: true
          },
          orderBy: sort === 'name' ? { firstName: 'asc' } : 
                   sort === 'date' ? { createdAt: 'desc' } :
                   sort === 'popularity' ? { analytics: { totalLogins: 'desc' } } :
                   [{ firstName: 'asc' }], // Default relevance
          skip: type === 'users' ? offset : 0,
          take: type === 'users' ? parseInt(limit) : Math.min(5, parseInt(limit))
        })

        const userResults = users.map(user => ({
          id: user.id,
          type: 'user',
          title: `${user.firstName} ${user.lastName}`,
          description: user.profile?.bio || '',
          avatarUrl: user.avatarUrl,
          location: user.profile?.location,
          skills: user.profile?.skills || [],
          createdAt: user.createdAt,
          relevanceScore: calculateUserRelevance(user, query)
        }))

        searchResults.results.push(...userResults)

        if (type === 'users') {
          const totalUsers = await prisma.user.count({ where: userSearchWhere })
          searchResults.pagination.total = totalUsers
          searchResults.pagination.totalPages = Math.ceil(totalUsers / parseInt(limit))
        }
      }

      if (type === 'all' || type === 'content') {
        const contentSearchWhere = {
          AND: [
            {
              OR: searchConditions.length > 0 ? [
                { title: { contains: query, mode: 'insensitive' } },
                { content: { contains: query, mode: 'insensitive' } },
                { tags: { hasSome: searchConditions } }
              ] : [{}]
            },
            { published: true },
            { 
              OR: [
                { visibility: 'public' },
                { authorId: userId },
                { 
                  author: {
                    connections: {
                      some: {
                        OR: [
                          { userId: userId, status: 'accepted' },
                          { connectedUserId: userId, status: 'accepted' }
                        ]
                      }
                    }
                  }
                }
              ]
            }
          ]
        }

        if (parsedFilters.category) {
          contentSearchWhere.AND.push({
            category: { equals: parsedFilters.category }
          })
        }

        if (parsedFilters.tags) {
          contentSearchWhere.AND.push({
            tags: { hasSome: parsedFilters.tags }
          })
        }

        const posts = await prisma.post.findMany({
          where: contentSearchWhere,
          include: {
            author: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                avatarUrl: true
              }
            },
            _count: {
              select: {
                likes: true,
                comments: true,
                shares: true
              }
            }
          },
          orderBy: sort === 'date' ? { createdAt: 'desc' } :
                   sort === 'popularity' ? { views: 'desc' } :
                   [{ createdAt: 'desc' }],
          skip: type === 'content' ? offset : 0,
          take: type === 'content' ? parseInt(limit) : Math.min(5, parseInt(limit))
        })

        const contentResults = posts.map(post => ({
          id: post.id,
          type: 'content',
          title: post.title,
          description: post.content?.substring(0, 200) + '...',
          author: post.author,
          category: post.category,
          tags: post.tags,
          stats: post._count,
          createdAt: post.createdAt,
          relevanceScore: calculateContentRelevance(post, query)
        }))

        searchResults.results.push(...contentResults)

        if (type === 'content') {
          const totalPosts = await prisma.post.count({ where: contentSearchWhere })
          searchResults.pagination.total = totalPosts
          searchResults.pagination.totalPages = Math.ceil(totalPosts / parseInt(limit))
        }
      }

      if (type === 'all' || type === 'products') {
        const productSearchWhere = {
          AND: [
            {
              OR: searchConditions.length > 0 ? [
                { name: { contains: query, mode: 'insensitive' } },
                { description: { contains: query, mode: 'insensitive' } },
                { category: { contains: query, mode: 'insensitive' } },
                { tags: { hasSome: searchConditions } }
              ] : [{}]
            },
            { status: 'active' }
          ]
        }

        if (parsedFilters.priceRange) {
          productSearchWhere.AND.push({
            price: {
              gte: parsedFilters.priceRange.min,
              lte: parsedFilters.priceRange.max
            }
          })
        }

        if (parsedFilters.category) {
          productSearchWhere.AND.push({
            category: { equals: parsedFilters.category }
          })
        }

        const products = await prisma.product.findMany({
          where: productSearchWhere,
          include: {
            _count: {
              select: {
                reviews: true,
                orders: true
              }
            }
          },
          orderBy: sort === 'name' ? { name: 'asc' } :
                   sort === 'date' ? { createdAt: 'desc' } :
                   sort === 'popularity' ? { views: 'desc' } :
                   [{ name: 'asc' }],
          skip: type === 'products' ? offset : 0,
          take: type === 'products' ? parseInt(limit) : Math.min(5, parseInt(limit))
        })

        const productResults = products.map(product => ({
          id: product.id,
          type: 'product',
          title: product.name,
          description: product.description,
          price: product.price,
          currency: product.currency,
          category: product.category,
          imageUrl: product.imageUrl,
          stats: product._count,
          createdAt: product.createdAt,
          relevanceScore: calculateProductRelevance(product, query)
        }))

        searchResults.results.push(...productResults)

        if (type === 'products') {
          const totalProducts = await prisma.product.count({ where: productSearchWhere })
          searchResults.pagination.total = totalProducts
          searchResults.pagination.totalPages = Math.ceil(totalProducts / parseInt(limit))
        }
      }

      if (facets && searchResults.results.length > 0) {
        const categoryFacets = {}
        searchResults.results.forEach(result => {
          const category = result.category || result.type
          categoryFacets[category] = (categoryFacets[category] || 0) + 1
        })
        searchResults.facets.categories = categoryFacets

        const now = new Date()
        const dateFacets = {
          'last_7_days': 0,
          'last_30_days': 0,
          'last_90_days': 0,
          'older': 0
        }

        searchResults.results.forEach(result => {
          const createdAt = new Date(result.createdAt)
          const daysDiff = Math.floor((now - createdAt) / (1000 * 60 * 60 * 24))
          
          if (daysDiff <= 7) dateFacets.last_7_days++
          else if (daysDiff <= 30) dateFacets.last_30_days++
          else if (daysDiff <= 90) dateFacets.last_90_days++
          else dateFacets.older++
        })
        searchResults.facets.dates = dateFacets

        const typeFacets = {}
        searchResults.results.forEach(result => {
          typeFacets[result.type] = (typeFacets[result.type] || 0) + 1
        })
        searchResults.facets.types = typeFacets
      }

      if (sort === 'relevance' && query) {
        searchResults.results.sort((a, b) => (b.relevanceScore || 0) - (a.relevanceScore || 0))
      }

      searchResults.executionTime = Date.now() - searchResults.executionTime

      await logActivity(userId, 'SEARCH_PERFORMED', {
        query,
        type,
        filters: parsedFilters,
        resultsCount: searchResults.results.length,
        executionTime: searchResults.executionTime,
        ipAddress: req.ip
      })

      await processAnalytics(userId, 'search', {
        query,
        type,
        resultsCount: searchResults.results.length,
        hasFilters: Object.keys(parsedFilters).length > 0,
        executionTime: searchResults.executionTime
      })

      if (query) {
        const searchKey = `popular_searches:${type}`
        await redis.zincrby(searchKey, 1, query.toLowerCase())
        await redis.expire(searchKey, 7 * 24 * 60 * 60) // 7 days TTL
      }

      res.json({
        success: true,
        ...searchResults
      })

    } catch (error) {
      logger.error('Search error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Search failed' })
    }
  }
)

const calculateUserRelevance = (user, query) => {
  if (!query) return 0
  
  let score = 0
  const searchTerms = query.toLowerCase().split(' ')
  
  searchTerms.forEach(term => {
    if (user.firstName?.toLowerCase().includes(term)) score += 10
    if (user.lastName?.toLowerCase().includes(term)) score += 10
    if (user.email?.toLowerCase().includes(term)) score += 5
    if (user.profile?.bio?.toLowerCase().includes(term)) score += 3
    if (user.profile?.skills?.some(skill => skill.toLowerCase().includes(term))) score += 7
  })
  
  if (user.profile?.bio && user.avatarUrl) score += 2
  
  if (user.analytics?.totalLogins > 10) score += 3
  
  return score
}

const calculateContentRelevance = (post, query) => {
  if (!query) return 0
  
  let score = 0
  const searchTerms = query.toLowerCase().split(' ')
  
  searchTerms.forEach(term => {
    if (post.title?.toLowerCase().includes(term)) score += 15
    if (post.content?.toLowerCase().includes(term)) score += 5
    if (post.tags?.some(tag => tag.toLowerCase().includes(term))) score += 8
  })
  
  if (post._count?.likes > 10) score += 3
  if (post._count?.comments > 5) score += 2
  
  return score
}

const calculateProductRelevance = (product, query) => {
  if (!query) return 0
  
  let score = 0
  const searchTerms = query.toLowerCase().split(' ')
  
  searchTerms.forEach(term => {
    if (product.name?.toLowerCase().includes(term)) score += 15
    if (product.description?.toLowerCase().includes(term)) score += 5
    if (product.category?.toLowerCase().includes(term)) score += 8
  })
  
  if (product._count?.orders > 10) score += 5
  if (product._count?.reviews > 5) score += 3
  
  return score
}

cron.schedule('0 2 * * *', async () => {
  logger.info('Running daily cleanup jobs...')
  
  try {
    await prisma.session.deleteMany({
      where: {
        expiresAt: { lt: new Date() }
      }
    })

    const ninetyDaysAgo = new Date()
    ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90)
    
    await prisma.activity.deleteMany({
      where: {
        timestamp: { lt: ninetyDaysAgo }
      }
    })

    const sevenDaysAgo = new Date()
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7)
    
    await prisma.export.deleteMany({
      where: {
        createdAt: { lt: sevenDaysAgo }
      }
    })

    const users = await prisma.user.findMany({
      where: { isActive: true },
      include: { analytics: true }
    })

    for (const user of users) {
      const lastActivity = user.analytics?.lastActivity
      if (lastActivity) {
        const daysSinceActivity = Math.floor((Date.now() - lastActivity.getTime()) / (1000 * 60 * 60 * 24))
        
        if (daysSinceActivity > 1) {
          await prisma.userAnalytics.update({
            where: { userId: user.id },
            data: { currentStreak: 0 }
          })
        }
      }
    }

    logger.info('Daily cleanup jobs completed successfully')
    
  } catch (error) {
    logger.error('Daily cleanup jobs failed:', error)
    Sentry.captureException(error)
  }
})

app.get('/api/health', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    services: {
      database: prisma ? 'connected' : 'disconnected',
      redis: redis.status === 'ready' ? 'connected' : 'disconnected',
      rabbitmq: rabbitmqConnection ? 'connected' : 'disconnected',
      stripe: stripe ? 'configured' : 'not_configured'
    },
    version: process.env.npm_package_version || '1.0.0',
    environment: process.env.NODE_ENV || 'development'
  })
})

app.use((error, req, res, next) => {
  logger.error('Unhandled error:', error)
  Sentry.captureException(error)
  
  if (error.name === 'ValidationError') {
    return res.status(400).json({
      error: 'Validation failed',
      details: error.details
    })
  }
  
  if (error.name === 'UnauthorizedError') {
    return res.status(401).json({
      error: 'Unauthorized access'
    })
  }
  
  if (error.code === 'P2002') {
    return res.status(409).json({
      error: 'Resource already exists',
      field: error.meta?.target
    })
  }
  
  res.status(500).json({
    error: 'Internal server error',
    requestId: req.headers['x-request-id'] || 'unknown'
  })
})

app.use('*', (req, res) => {
  res.status(404).json({
    error: 'Endpoint not found',
    method: req.method,
    path: req.originalUrl
  })
})

process.on('SIGTERM', async () => {
  logger.info('SIGTERM received, starting graceful shutdown...')
  
  try {
    await prisma.$disconnect()
    
    redis.disconnect()
    
    if (rabbitmqConnection) {
      await rabbitmqConnection.close()
    }
    
    logger.info('Graceful shutdown completed')
    process.exit(0)
  } catch (error) {
    logger.error('Error during shutdown:', error)
    process.exit(1)
  }
})

process.on('SIGINT', async () => {
  logger.info('SIGINT received, starting graceful shutdown...')
  
  try {
    await prisma.$disconnect()
    redis.disconnect()
    
    if (rabbitmqConnection) {
      await rabbitmqConnection.close()
    }
    
    logger.info('Graceful shutdown completed')
    process.exit(0)
  } catch (error) {
    logger.error('Error during shutdown:', error)
    process.exit(1)
  }
})

app.get('/api/dashboard',
  strictRateLimit,
  authenticateJWT,
  async (req, res) => {
    try {
      const userId = req.user.id
      const { timeframe = '7d' } = req.query

      const endDate = new Date()
      const startDate = new Date()
      
      switch (timeframe) {
        case '24h':
          startDate.setHours(endDate.getHours() - 24)
          break
        case '7d':
          startDate.setDate(endDate.getDate() - 7)
          break
        case '30d':
          startDate.setDate(endDate.getDate() - 30)
          break
        case '90d':
          startDate.setDate(endDate.getDate() - 90)
          break
      }

      const [
        userStats,
        recentActivities,
        notifications,
        realtimeMetrics,
        topContent,
        connections,
        financialStats,
        systemHealth
      ] = await Promise.all([
        prisma.userAnalytics.findUnique({
          where: { userId }
        }),

        prisma.activity.findMany({
          where: {
            userId,
            timestamp: { gte: startDate }
          },
          orderBy: { timestamp: 'desc' },
          take: 10
        }),

        prisma.userNotification.findMany({
          where: {
            userId,
            read: false
          },
          orderBy: { createdAt: 'desc' },
          take: 5
        }),

        (async () => {
          const keys = await redis.keys(`analytics:${userId}:*`)
          const metrics = {}
          
          for (const key of keys) {
            const data = await redis.hgetall(key)
            const date = key.split(':')[2]
            metrics[date] = data
          }
          
          return metrics
        })(),

        prisma.post.findMany({
          where: {
            authorId: userId,
            createdAt: { gte: startDate }
          },
          include: {
            _count: {
              select: {
                likes: true,
                comments: true,
                shares: true
              }
            }
          },
          orderBy: [
            { views: 'desc' },
            { createdAt: 'desc' }
          ],
          take: 5
        }),

        prisma.connection.findMany({
          where: {
            OR: [
              { userId, status: 'accepted' },
              { connectedUserId: userId, status: 'accepted' }
            ],
            createdAt: { gte: startDate }
          },
          include: {
            user: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                avatarUrl: true
              }
            },
            connectedUser: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                avatarUrl: true
              }
            }
          },
          orderBy: { createdAt: 'desc' },
          take: 5
        }),

        prisma.transaction.aggregate({
          where: {
            userId,
            status: 'completed',
            createdAt: { gte: startDate }
          },
          _sum: { amount: true },
          _count: true,
          _avg: { amount: true }
        }),

        (async () => {
          try {
            const dbHealth = await prisma.$queryRaw`SELECT 1`
            const redisHealth = await redis.ping()
            
            return {
              database: !!dbHealth,
              redis: redisHealth === 'PONG',
              timestamp: new Date()
            }
          } catch (error) {
            return {
              database: false,
              redis: false,
              error: error.message,
              timestamp: new Date()
            }
          }
        })()
      ])

      // Process activity trends
      const activityTrends = {}
      recentActivities.forEach(activity => {
        const date = moment(activity.timestamp).format('YYYY-MM-DD')
        if (!activityTrends[date]) {
          activityTrends[date] = {}
        }
        if (!activityTrends[date][activity.action]) {
          activityTrends[date][activity.action] = 0
        }
        activityTrends[date][activity.action]++
      })

      // Calculate growth metrics
      const previousPeriodStart = new Date(startDate)
      const periodLength = endDate - startDate
      previousPeriodStart.setTime(previousPeriodStart.getTime() - periodLength)

      const previousPeriodActivities = await prisma.activity.count({
        where: {
          userId,
          timestamp: {
            gte: previousPeriodStart,
            lt: startDate
          }
        }
      })

      const currentPeriodActivities = recentActivities.length
      const activityGrowth = previousPeriodActivities > 0 
        ? ((currentPeriodActivities - previousPeriodActivities) / previousPeriodActivities) * 100
        : 0

      // Prepare dashboard response
      const dashboardData = {
        user: {
          id: userId,
          name: `${req.user.firstName} ${req.user.lastName}`,
          avatar: req.user.avatarUrl,
          subscriptionPlan: req.user.subscriptionPlan || 'free',
          joinDate: req.user.createdAt
        },
        
        stats: {
          totalLogins: userStats?.totalLogins || 0,
          totalActivities: currentPeriodActivities,
          activityGrowth: Math.round(activityGrowth * 100) / 100,
          lastActivity: userStats?.lastActivity,
          currentStreak: userStats?.currentStreak || 0,
          longestStreak: userStats?.longestStreak || 0
        },

        activities: {
          recent: recentActivities.map(activity => ({
            id: activity.id,
            action: activity.action,
            timestamp: activity.timestamp,
            details: JSON.parse(activity.details || '{}'),
            ipAddress: activity.ipAddress,
            location: activity.location
          })),
          trends: activityTrends,
          total: currentPeriodActivities
        },

        notifications: {
          unread: notifications.map(notification => ({
            id: notification.id,
            title: notification.title,
            message: notification.message,
            type: notification.type,
            priority: notification.priority,
            createdAt: notification.createdAt,
            data: JSON.parse(notification.data || '{}')
          })),
          count: notifications.length
        },

        content: {
          topPosts: topContent.map(post => ({
            id: post.id,
            title: post.title,
            views: post.views,
            engagement: post._count,
            createdAt: post.createdAt
          })),
          totalViews: topContent.reduce((sum, post) => sum + (post.views || 0), 0)
        },

        social: {
          recentConnections: connections.map(conn => ({
            id: conn.id,
            user: conn.userId === userId ? conn.connectedUser : conn.user,
            connectedAt: conn.createdAt
          })),
          totalConnections: connections.length
        },

        financial: {
          totalSpent: financialStats._sum.amount || 0,
          transactionCount: financialStats._count || 0,
          averageTransaction: financialStats._avg.amount || 0,
          currency: 'USD' // Default currency
        },

        realtime: realtimeMetrics,

        system: {
          health: systemHealth,
          performance: {
            responseTime: Date.now() - req.startTime,
            memoryUsage: process.memoryUsage(),
            uptime: process.uptime()
          }
        },

        insights: []
      }

      // Generate insights based on data
      if (dashboardData.stats.activityGrowth > 20) {
        dashboardData.insights.push({
          type: 'positive',
          title: 'Activity Surge',
          message: `Your activity increased by ${dashboardData.stats.activityGrowth.toFixed(1)}% this period!`
        })
      }

      if (dashboardData.stats.currentStreak > 7) {
        dashboardData.insights.push({
          type: 'achievement',
          title: 'Streak Master',
          message: `You're on a ${dashboardData.stats.currentStreak}-day activity streak!`
        })
      }

      if (dashboardData.content.totalViews > 1000) {
        dashboardData.insights.push({
          type: 'milestone',
          title: 'Content Star',
          message: `Your content received over ${dashboardData.content.totalViews} views this period!`
        })
      }

      if (dashboardData.notifications.count > 10) {
        dashboardData.insights.push({
          type: 'warning',
          title: 'Notification Backlog',
          message: `You have ${dashboardData.notifications.count} unread notifications.`
        })
      }

      // Log dashboard access
      await logActivity(userId, 'DASHBOARD_ACCESSED', {
        timeframe,
        loadTime: Date.now() - req.startTime,
        ipAddress: req.ip
      })

      // Process analytics
      await processAnalytics(userId, 'dashboard_view', {
        timeframe,
        hasUnreadNotifications: dashboardData.notifications.count > 0,
        activityTrend: dashboardData.stats.activityGrowth > 0 ? 'up' : 'down'
      })

      res.json({
        success: true,
        data: dashboardData,
        meta: {
          timeframe,
          generatedAt: new Date().toISOString(),
          loadTime: Date.now() - req.startTime
        }
      })

    } catch (error) {
      logger.error('Dashboard error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Dashboard load failed' })
    }
  }
)

// Complex Bulk Operations API
app.post('/api/bulk/:operation',
  strictRateLimit,
  authenticateJWT,
  upload.single('file'),
  [
    param('operation').isIn(['delete', 'update', 'export', 'import', 'process']),
    body('targets').optional().isArray(),
    body('criteria').optional().isJSON(),
    body('data').optional().isJSON(),
    body('options').optional().isJSON()
  ],
  validateRequest,
  async (req, res) => {
    try {
      const { operation } = req.params
      const {
        targets = [],
        criteria = '{}',
        data = '{}',
        options = '{}'
      } = req.body

      const userId = req.user.id
      const parsedCriteria = JSON.parse(criteria)
      const parsedData = JSON.parse(data)
      const parsedOptions = JSON.parse(options)
      const operationId = uuidv4()

      // Check permissions for bulk operations
      if (!req.user.permissions?.bulk?.[operation]) {
        return res.status(403).json({ 
          error: `Insufficient permissions for bulk ${operation}` 
        })
      }

      // Create bulk operation record
      const bulkOperation = await prisma.bulkOperation.create({
        data: {
          id: operationId,
          userId,
          type: operation,
          status: 'processing',
          targetCount: targets.length,
          criteria: parsedCriteria,
          options: parsedOptions,
          createdAt: new Date()
        }
      })

      let results = {
        processed: 0,
        successful: 0,
        failed: 0,
        errors: []
      }

      try {
        switch (operation) {
          case 'delete':
            // Bulk delete operation
            if (parsedCriteria.type === 'posts' && targets.length > 0) {
              // Verify ownership
              const posts = await prisma.post.findMany({
                where: {
                  id: { in: targets },
                  authorId: userId
                }
              })

              for (const post of posts) {
                try {
                  await prisma.$transaction(async (tx) => {
                    // Delete related data first
                    await tx.comment.deleteMany({ where: { postId: post.id } })
                    await tx.like.deleteMany({ where: { postId: post.id } })
                    await tx.share.deleteMany({ where: { postId: post.id } })
                    await tx.bookmark.deleteMany({ where: { postId: post.id } })
                    
                    // Delete the post
                    await tx.post.delete({ where: { id: post.id } })
                  })

                  results.successful++
                } catch (deleteError) {
                  results.failed++
                  results.errors.push({
                    target: post.id,
                    error: deleteError.message
                  })
                }
                results.processed++
              }
            }
            break

          case 'update':
            // Bulk update operation
            if (parsedCriteria.type === 'users' && parsedData.updates) {
              const userIds = targets.length > 0 ? targets : [userId]
              
              for (const targetUserId of userIds) {
                // Check if user can update this target
                if (targetUserId !== userId && !req.user.permissions?.users?.updateOthers) {
                  results.failed++
                  results.errors.push({
                    target: targetUserId,
                    error: 'Insufficient permissions'
                  })
                  continue
                }

                try {
                  await prisma.user.update({
                    where: { id: targetUserId },
                    data: parsedData.updates
                  })
                  results.successful++
                } catch (updateError) {
                  results.failed++
                  results.errors.push({
                    target: targetUserId,
                    error: updateError.message
                  })
                }
                results.processed++
              }
            }
            break

          case 'export':
            // Bulk export operation
            let exportData = []
            let filename = `export-${operationId}.json`
            let contentType = 'application/json'

            if (parsedCriteria.type === 'analytics') {
              const analytics = await prisma.activity.findMany({
                where: {
                  userId,
                  timestamp: {
                    gte: parsedCriteria.startDate ? new Date(parsedCriteria.startDate) : undefined,
                    lte: parsedCriteria.endDate ? new Date(parsedCriteria.endDate) : undefined
                  }
                },
                orderBy: { timestamp: 'desc' },
                take: parsedOptions.limit || 10000
              })

              exportData = analytics.map(activity => ({
                date: activity.timestamp.toISOString(),
                action: activity.action,
                details: JSON.parse(activity.details || '{}'),
                ipAddress: activity.ipAddress,
                location: activity.location
              }))

              // Generate different formats
              if (parsedOptions.format === 'csv') {
                const csvData = [
                  'Date,Action,Details,IP Address,Location',
                  ...exportData.map(row => 
                    `"${row.date}","${row.action}","${JSON.stringify(row.details).replace(/"/g, '""')}","${row.ipAddress || ''}","${row.location || ''}"`
                  )
                ].join('\n')

                exportData = csvData
                filename = `analytics-${operationId}.csv`
                contentType = 'text/csv'
              } else if (parsedOptions.format === 'xlsx') {
                const workbook = new ExcelJS.Workbook()
                const worksheet = workbook.addWorksheet('Analytics')

                worksheet.columns = [
                  { header: 'Date', key: 'date', width: 25 },
                  { header: 'Action', key: 'action', width: 20 },
                  { header: 'Details', key: 'details', width: 40 },
                  { header: 'IP Address', key: 'ipAddress', width: 15 },
                  { header: 'Location', key: 'location', width: 20 }
                ]

                exportData.forEach(row => {
                  worksheet.addRow({
                    date: row.date,
                    action: row.action,
                    details: JSON.stringify(row.details),
                    ipAddress: row.ipAddress,
                    location: row.location
                  })
                })

                exportData = await workbook.xlsx.writeBuffer()
                filename = `analytics-${operationId}.xlsx`
                contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
              }

              results.successful = exportData.length || 1
              results.processed = exportData.length || 1
            }

            // Store export file (in production, upload to S3)
            if (parsedOptions.format !== 'xlsx') {
              await fs.writeFile(`/tmp/${filename}`, typeof exportData === 'string' ? exportData : JSON.stringify(exportData, null, 2))
            } else {
              await fs.writeFile(`/tmp/${filename}`, exportData)
            }

            // Update bulk operation with file info
            await prisma.bulkOperation.update({
              where: { id: operationId },
              data: {
                resultData: JSON.stringify({
                  filename,
                  contentType,
                  size: typeof exportData === 'string' ? exportData.length : Buffer.byteLength(JSON.stringify(exportData))
                })
              }
            })

            break

          case 'process':
            // Bulk process operation (e.g., image processing, data transformation)
            if (req.file && parsedCriteria.type === 'images') {
              const processedImages = []
              
              // This would typically process multiple images from a zip file
              // For demo, we'll process the single uploaded file
              if (req.file.mimetype.startsWith('image/')) {
                try {
                  // Process image with different sizes
                  const sizes = [
                    { name: 'thumbnail', width: 150, height: 150 },
                    { name: 'small', width: 400, height: 300 },
                    { name: 'medium', width: 800, height: 600 },
                    { name: 'large', width: 1200, height: 900 }
                  ]

                  for (const size of sizes) {
                    const processedImage = await processImage(req.file.buffer, {
                      width: size.width,
                      height: size.height,
                      quality: 85,
                      format: 'jpeg'
                    })

                    const imageKey = `processed/${operationId}/${size.name}-${uuidv4()}.jpg`
                    const imageUrl = await uploadToS3(processedImage, imageKey, 'image/jpeg')
                    
                    processedImages.push({
                      size: size.name,
                      url: imageUrl,
                      dimensions: `${size.width}x${size.height}`
                    })
                  }

                  results.successful = processedImages.length
                  results.processed = 1

                  await prisma.bulkOperation.update({
                    where: { id: operationId },
                    data: {
                      resultData: JSON.stringify({ processedImages })
                    }
                  })

                } catch (processError) {
                  results.failed = 1
                  results.errors.push({
                    target: req.file.originalname,
                    error: processError.message
                  })
                }
              }
            }
            break

          default:
            throw new Error(`Unsupported bulk operation: ${operation}`)
        }

        // Update operation status
        await prisma.bulkOperation.update({
          where: { id: operationId },
          data: {
            status: results.failed > 0 ? 'completed_with_errors' : 'completed',
            processedCount: results.processed,
            successCount: results.successful,
            failedCount: results.failed,
            errors: JSON.stringify(results.errors),
            completedAt: new Date()
          }
        })

        // Send completion notification
        const completionHtml = `
          <h2>Bulk ${operation.charAt(0).toUpperCase() + operation.slice(1)} Completed</h2>
          <p>Your bulk operation has finished processing.</p>
          <p><strong>Operation ID:</strong> ${operationId}</p>
          <p><strong>Processed:</strong> ${results.processed}</p>
          <p><strong>Successful:</strong> ${results.successful}</p>
          <p><strong>Failed:</strong> ${results.failed}</p>
          ${results.errors.length > 0 ? `<p><strong>Errors:</strong> ${results.errors.length}</p>` : ''}
          <p>You can view detailed results in your dashboard.</p>
        `

        if (rabbitmqChannel) {
          await rabbitmqChannel.sendToQueue(
            'email_queue',
            Buffer.from(JSON.stringify({
              to: req.user.email,
              subject: `Bulk ${operation} Completed`,
              html: completionHtml,
              priority: 'normal'
            })),
            { persistent: true }
          )
        }

        // Log bulk operation
        await logActivity(userId, 'BULK_OPERATION_COMPLETED', {
          operationId,
          type: operation,
          processed: results.processed,
          successful: results.successful,
          failed: results.failed,
          ipAddress: req.ip
        })

        // Process analytics
        await processAnalytics(userId, 'bulk_operation', {
          type: operation,
          itemCount: results.processed,
          successRate: results.processed > 0 ? (results.successful / results.processed) * 100 : 0,
          hasErrors: results.failed > 0
        })

        res.json({
          success: true,
          message: `Bulk ${operation} completed`,
          operationId,
          results: {
            processed: results.processed,
            successful: results.successful,
            failed: results.failed,
            errors: results.errors.slice(0, 10) // Return first 10 errors
          }
        })

      } catch (operationError) {
        // Update operation as failed
        await prisma.bulkOperation.update({
          where: { id: operationId },
          data: {
            status: 'failed',
            errors: JSON.stringify([{ message: operationError.message }]),
            completedAt: new Date()
          }
        })

        throw operationError
      }

    } catch (error) {
      logger.error('Bulk operation error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Bulk operation failed', details: error.message })
    }
  }
)

// Export the router
export default app

// Start server if this file is run directly
if (process.env.NODE_ENV !== 'test') {
  const PORT = process.env.PORT || 3001
  const server = app.listen(PORT, () => {
    logger.info(` Server running on port ${PORT}`)
    logger.info(` Environment: ${process.env.NODE_ENV || 'development'}`)
    logger.info(` Started at: ${new Date().toISOString()}`)
  })

  // Socket.io setup for real-time features
  const io = socketio(server, {
    cors: {
      origin: process.env.FRONTEND_URL || 'http://localhost:3000',
      methods: ['GET', 'POST']
    }
  })

  // Socket authentication middleware
  io.use(async (socket, next) => {
    try {
      const token = socket.handshake.auth.token
      if (!token) {
        return next(new Error('Authentication token required'))
      }

      const decoded = jwt.verify(token, process.env.JWT_SECRET)
      const user = await userLoader.load(decoded.userId)

      if (!user || !user.isActive) {
        return next(new Error('Invalid or inactive user'))
      }

      socket.userId = user.id
      socket.user = user
      next()
    } catch (error) {
      next(new Error('Authentication failed'))
    }
  })

  // Socket connection handling
  io.on('connection', (socket) => {
    logger.info(`User ${socket.userId} connected via Socket.IO`)
    
    // Join user-specific room
    socket.join(`user:${socket.userId}`)
    
    // Handle real-time activity tracking
    socket.on('activity', async (data) => {
      try {
        await processAnalytics(socket.userId, 'realtime_activity', {
          type: data.type,
          page: data.page,
          duration: data.duration
        })
        
        // Update last activity
        await redis.setex(`user_activity:${socket.userId}`, 300, Date.now()) // 5 min TTL
      } catch (error) {
        logger.error('Real-time activity error:', error)
      }
    })
    
    // Handle typing indicators for chat
    socket.on('typing_start', (data) => {
      socket.to(`conversation:${data.conversationId}`).emit('user_typing', {
        userId: socket.userId,
        userName: `${socket.user.firstName} ${socket.user.lastName}`
      })
    })
    
    socket.on('typing_stop', (data) => {
      socket.to(`conversation:${data.conversationId}`).emit('user_stopped_typing', {
        userId: socket.userId
      })
    })
    
    // Handle presence updates
    socket.on('presence_update', async (status) => {
      try {
        await redis.setex(`presence:${socket.userId}`, 300, JSON.stringify({
          status,
          lastSeen: Date.now(),
          socketId: socket.id
        }))
        
        // Broadcast to connections
        socket.broadcast.emit('user_presence_updated', {
          userId: socket.userId,
          status,
          timestamp: Date.now()
        })
      } catch (error) {
        logger.error('Presence update error:', error)
      }
    })
    
    socket.on('disconnect', async (reason) => {
      logger.info(`User ${socket.userId} disconnected: ${reason}`)
      
      // Update presence to offline
      try {
        await redis.setex(`presence:${socket.userId}`, 300, JSON.stringify({
          status: 'offline',
          lastSeen: Date.now(),
          socketId: null
        }))
        
        socket.broadcast.emit('user_presence_updated', {
          userId: socket.userId,
          status: 'offline',
          timestamp: Date.now()
        })
      } catch (error) {
        logger.error('Disconnect presence update error:', error)
      }
    })
  })

  // Store io instance for use in other parts of the app
  app.set('io', io)

  // Handle server shutdown
    server.on('close', async () => {
    logger.info('HTTP server closing...')
    io.close()
  })
}

app.post('/api/ai/analyze-content',
  strictRateLimit,
  authenticateJWT,
  upload.single('file'),
  [
    body('text').optional().isLength({ max: 10000 }),
    body('analysisType').isIn(['sentiment', 'toxicity', 'keywords', 'summary', 'translation', 'classification']),
    body('language').optional().isIn(['en', 'es', 'fr', 'de', 'it', 'pt']),
    body('options').optional().isJSON()
  ],
  validateRequest,
  async (req, res) => {
    try {
      const { text, analysisType, language = 'en', options = '{}' } = req.body
      const userId = req.user.id
      const parsedOptions = JSON.parse(options)
      
      let contentToAnalyze = text

      // Extract text from uploaded file if provided
      if (req.file && !text) {
        const fileExtension = path.extname(req.file.originalname).toLowerCase()
        
        switch (fileExtension) {
          case '.pdf':
            // Extract text from PDF
            contentToAnalyze = await extractTextFromPDF(req.file.buffer)
            break
          case '.docx':
            // Extract text from Word document
            const mammoth = await import('mammoth')
            const result = await mammoth.extractRawText({ buffer: req.file.buffer })
            contentToAnalyze = result.value
            break
          case '.txt':
            contentToAnalyze = req.file.buffer.toString('utf8')
            break
          default:
            return res.status(400).json({ error: 'Unsupported file type for text extraction' })
        }
      }

      if (!contentToAnalyze) {
        return res.status(400).json({ error: 'No content provided for analysis' })
      }

      // Rate limit AI API calls
      const aiRateKey = `ai_calls:${userId}:${moment().format('YYYY-MM-DD-HH')}`
      const currentCalls = await redis.incr(aiRateKey)
      await redis.expire(aiRateKey, 3600) // 1 hour TTL

      const maxCalls = req.user.subscriptionPlan === 'enterprise' ? 1000 : 
                     req.user.subscriptionPlan === 'pro' ? 500 : 100
      
      if (currentCalls > maxCalls) {
        return res.status(429).json({ 
          error: 'AI API rate limit exceeded',
          limit: maxCalls,
          resetTime: moment().add(1, 'hour').toISOString()
        })
      }

      let analysisResult = {}

      // Perform AI analysis based on type
      switch (analysisType) {
        case 'sentiment':
          analysisResult = await performSentimentAnalysis(contentToAnalyze, language)
          break
        case 'toxicity':
          analysisResult = await performToxicityDetection(contentToAnalyze)
          break
        case 'keywords':
          analysisResult = await extractKeywords(contentToAnalyze, parsedOptions.maxKeywords || 20)
          break
        case 'summary':
          analysisResult = await generateSummary(contentToAnalyze, parsedOptions.maxLength || 200)
          break
        case 'translation':
          const targetLanguage = parsedOptions.targetLanguage || 'en'
          analysisResult = await translateText(contentToAnalyze, language, targetLanguage)
          break
        case 'classification':
          analysisResult = await classifyContent(contentToAnalyze, parsedOptions.categories)
          break
      }

      // Store analysis result
      const analysis = await prisma.contentAnalysis.create({
        data: {
          userId,
          type: analysisType,
          inputText: contentToAnalyze.substring(0, 1000), // Store first 1000 chars
          result: JSON.stringify(analysisResult),
          language,
          options: parsedOptions,
          processingTime: analysisResult.processingTime,
          tokensUsed: analysisResult.tokensUsed || 0,
          cost: calculateAICost(analysisResult.tokensUsed || 0, analysisType),
          createdAt: new Date()
        }
      })

      // Update user's AI usage stats
      await prisma.userAnalytics.update({
        where: { userId },
        data: {
          totalAICallsCount: { increment: 1 },
          totalAITokensUsed: { increment: analysisResult.tokensUsed || 0 },
          totalAICost: { increment: analysis.cost }
        }
      })

      // Log AI usage
      await logActivity(userId, 'AI_CONTENT_ANALYZED', {
        type: analysisType,
        language,
        textLength: contentToAnalyze.length,
        tokensUsed: analysisResult.tokensUsed,
        cost: analysis.cost,
        ipAddress: req.ip
      })

      // Process analytics
      await processAnalytics(userId, 'ai_analysis', {
        type: analysisType,
        language,
        textLength: contentToAnalyze.length,
        processingTime: analysisResult.processingTime
      })

      res.json({
        success: true,
        analysisId: analysis.id,
        type: analysisType,
        result: analysisResult,
        usage: {
          tokensUsed: analysisResult.tokensUsed || 0,
          cost: analysis.cost,
          remainingCalls: maxCalls - currentCalls
        }
      })

    } catch (error) {
      logger.error('AI content analysis error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Content analysis failed' })
    }
  }
)

// AI Analysis Helper Functions
const performSentimentAnalysis = async (text, language) => {
  const startTime = Date.now()
  
  // Mock AI service call - replace with actual AI API (OpenAI, Google Cloud AI, etc.)
  const mockSentiment = {
    score: Math.random() * 2 - 1, // -1 to 1
    magnitude: Math.random(),
    label: Math.random() > 0.5 ? 'positive' : Math.random() > 0.25 ? 'negative' : 'neutral'
  }
  
  return {
    sentiment: mockSentiment,
    confidence: Math.random() * 0.3 + 0.7, // 0.7 to 1.0
    processingTime: Date.now() - startTime,
    tokensUsed: Math.ceil(text.length / 4) // Rough token estimate
  }
}

const performToxicityDetection = async (text) => {
  const startTime = Date.now()
  
  // Mock toxicity detection
  const toxicityScores = {
    toxic: Math.random() * 0.3,
    severe_toxic: Math.random() * 0.1,
    obscene: Math.random() * 0.2,
    threat: Math.random() * 0.1,
    insult: Math.random() * 0.3,
    identity_hate: Math.random() * 0.1
  }
  
  const maxScore = Math.max(...Object.values(toxicityScores))
  
  return {
    scores: toxicityScores,
    overallScore: maxScore,
    isToxic: maxScore > 0.5,
    flaggedCategories: Object.entries(toxicityScores)
      .filter(([_, score]) => score > 0.5)
      .map(([category]) => category),
    processingTime: Date.now() - startTime,
    tokensUsed: Math.ceil(text.length / 4)
  }
}

const extractKeywords = async (text, maxKeywords) => {
  const startTime = Date.now()
  
  // Simple keyword extraction (in production, use NLP libraries or AI APIs)
  const words = text.toLowerCase()
    .replace(/[^\w\s]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length > 3)
  
  const stopWords = new Set(['this', 'that', 'with', 'have', 'will', 'been', 'from', 'they', 'know', 'want', 'been', 'good', 'much', 'some', 'time', 'very', 'when', 'come', 'here', 'just', 'like', 'long', 'make', 'many', 'over', 'such', 'take', 'than', 'them', 'well', 'were'])
  
  const wordCounts = {}
  words.forEach(word => {
    if (!stopWords.has(word)) {
      wordCounts[word] = (wordCounts[word] || 0) + 1
    }
  })
  
  const keywords = Object.entries(wordCounts)
    .sort(([,a], [,b]) => b - a)
    .slice(0, maxKeywords)
    .map(([word, count]) => ({
      keyword: word,
      frequency: count,
      relevance: count / words.length
    }))
  
  return {
    keywords,
    totalWords: words.length,
    uniqueWords: Object.keys(wordCounts).length,
    processingTime: Date.now() - startTime,
    tokensUsed: Math.ceil(text.length / 4)
  }
}

const generateSummary = async (text, maxLength) => {
  const startTime = Date.now()
  
  // Simple extractive summary (in production, use AI APIs)
  const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 10)
  
  if (sentences.length <= 3) {
    return {
      summary: text,
      compressionRatio: 1,
      originalLength: text.length,
      summaryLength: text.length,
      processingTime: Date.now() - startTime,
      tokensUsed: Math.ceil(text.length / 4)
    }
  }
  
  // Score sentences based on word frequency
  const wordFreq = {}
  const words = text.toLowerCase().split(/\W+/).filter(w => w.length > 3)
  words.forEach(word => {
    wordFreq[word] = (wordFreq[word] || 0) + 1
  })
  
  const sentenceScores = sentences.map(sentence => {
    const sentenceWords = sentence.toLowerCase().split(/\W+/)
    const score = sentenceWords.reduce((sum, word) => sum + (wordFreq[word] || 0), 0) / sentenceWords.length
    return { sentence: sentence.trim(), score }
  })
  
  const topSentences = sentenceScores
    .sort((a, b) => b.score - a.score)
    .slice(0, Math.min(3, sentences.length))
    .map(item => item.sentence)
    .join('. ')
  
  const summary = topSentences.length <= maxLength ? 
    topSentences : 
    topSentences.substring(0, maxLength - 3) + '...'
  
  return {
    summary,
    compressionRatio: summary.length / text.length,
    originalLength: text.length,
    summaryLength: summary.length,
    processingTime: Date.now() - startTime,
    tokensUsed: Math.ceil(text.length / 4)
  }
}

const translateText = async (text, sourceLanguage, targetLanguage) => {
  const startTime = Date.now()
  
  // Mock translation (in production, use Google Translate API, DeepL, etc.)
  const mockTranslations = {
    'en-es': text.replace(/hello/gi, 'hola').replace(/world/gi, 'mundo'),
    'en-fr': text.replace(/hello/gi, 'bonjour').replace(/world/gi, 'monde'),
    'es-en': text.replace(/hola/gi, 'hello').replace(/mundo/gi, 'world')
  }
  
  const translationKey = `${sourceLanguage}-${targetLanguage}`
  const translatedText = mockTranslations[translationKey] || `[Translated from ${sourceLanguage} to ${targetLanguage}] ${text}`
  
  return {
    translatedText,
    sourceLanguage,
    targetLanguage,
    confidence: 0.95,
    processingTime: Date.now() - startTime,
    tokensUsed: Math.ceil(text.length / 4)
  }
}

const classifyContent = async (text, categories) => {
  const startTime = Date.now()
  
  // Mock content classification
  const defaultCategories = ['technology', 'business', 'entertainment', 'sports', 'politics', 'science', 'health']
  const availableCategories = categories || defaultCategories
  
  const classifications = availableCategories.map(category => ({
    category,
    confidence: Math.random(),
    score: Math.random()
  })).sort((a, b) => b.confidence - a.confidence)
  
  return {
    classifications,
    topCategory: classifications[0],
    processingTime: Date.now() - startTime,
    tokensUsed: Math.ceil(text.length / 4)
  }
}

const calculateAICost = (tokensUsed, analysisType) => {
  // Mock pricing calculation (adjust based on actual AI service pricing)
  const baseCostPerToken = {
    sentiment: 0.0001,
    toxicity: 0.0002,
    keywords: 0.00005,
    summary: 0.0003,
    translation: 0.0002,
    classification: 0.0001
  }
  
  return (tokensUsed * (baseCostPerToken[analysisType] || 0.0001))
}

const extractTextFromPDF = async (pdfBuffer) => {
  // Mock PDF text extraction (use libraries like pdf-parse in production)
  return "Extracted text from PDF document..."
}

// Advanced Caching and Performance API
app.get('/api/cache/performance',
  authenticateJWT,
  async (req, res) => {
    try {
      const { operation = 'stats', keys, pattern, ttl } = req.query
      const userId = req.user.id

      // Check admin permissions for cache operations
      if (!req.user.permissions?.admin?.cacheAccess) {
        return res.status(403).json({ error: 'Insufficient permissions' })
      }

      let result = {}

      switch (operation) {
        case 'stats':
          // Get Redis cache statistics
          const info = await redis.info('memory')
          const dbSize = await redis.dbsize()
          const keyspace = await redis.info('keyspace')
          
          result = {
            memoryUsage: parseRedisInfo(info),
            totalKeys: dbSize,
            keyspaceInfo: parseRedisInfo(keyspace),
            performance: {
              avgResponseTime: await getAverageResponseTime(),
              cacheHitRatio: await getCacheHitRatio(),
              operationsPerSecond: await getOperationsPerSecond()
            }
          }
          break

        case 'keys':
          // List keys matching pattern
          const keyPattern = pattern || `user:${userId}:*`
          const matchingKeys = await redis.keys(keyPattern)
          const keyDetails = []

          for (const key of matchingKeys.slice(0, 100)) { // Limit to 100 keys
            const ttlValue = await redis.ttl(key)
            const keyType = await redis.type(key)
            let size = 0

            try {
              const keyData = await redis.get(key)
              size = keyData ? keyData.length : 0
            } catch (error) {
              // Key might be complex type
              size = await redis.memory('usage', key).catch(() => 0)
            }

            keyDetails.push({
              key,
              type: keyType,
              ttl: ttlValue,
              size,
              sizeFormatted: formatBytes(size)
            })
          }

          result = {
            pattern: keyPattern,
            totalMatches: matchingKeys.length,
            keys: keyDetails,
            truncated: matchingKeys.length > 100
          }
          break

        case 'invalidate':
          // Invalidate cache keys
          if (keys) {
            const keysList = Array.isArray(keys) ? keys : [keys]
            const deletedCount = await redis.del(...keysList)
            result = {
              deletedKeys: deletedCount,
              keys: keysList
            }
          } else if (pattern) {
            const matchingKeys = await redis.keys(pattern)
            const deletedCount = matchingKeys.length > 0 ? await redis.del(...matchingKeys) : 0
            result = {
              deletedKeys: deletedCount,
              pattern,
              matchedKeys: matchingKeys.length
            }
          }
          break

        case 'warm':
          // Warm up cache with frequently accessed data
          const warmupResults = await warmupCache(userId)
          result = {
            message: 'Cache warmup completed',
            ...warmupResults
          }
          break

        case 'analyze':
          // Analyze cache usage patterns
          const analysisResults = await analyzeCacheUsage()
          result = analysisResults
          break

        default:
          return res.status(400).json({ error: 'Invalid cache operation' })
      }

      // Log cache operation
      await logActivity(userId, 'CACHE_OPERATION', {
        operation,
        keys: keys || pattern,
        ipAddress: req.ip
      })

      res.json({
        success: true,
        operation,
        timestamp: new Date().toISOString(),
        result
      })

    } catch (error) {
      logger.error('Cache performance API error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Cache operation failed' })
    }
  }
)

// Cache helper functions
const parseRedisInfo = (info) => {
  const lines = info.split('\r\n')
  const parsed = {}
  
  lines.forEach(line => {
    if (line.includes(':')) {
      const [key, value] = line.split(':')
      parsed[key] = isNaN(value) ? value : Number(value)
    }
  })
  
  return parsed
}

const getAverageResponseTime = async () => {
  // Mock implementation - in production, track actual response times
  return Math.random() * 10 + 5 // 5-15ms
}

const getCacheHitRatio = async () => {
  try {
    const info = await redis.info('stats')
    const stats = parseRedisInfo(info)
    
    const hits = stats.keyspace_hits || 0
    const misses = stats.keyspace_misses || 0
    const total = hits + misses
    
    return total > 0 ? (hits / total) * 100 : 0
  } catch (error) {
    return 0
  }
}

const getOperationsPerSecond = async () => {
  try {
    const info = await redis.info('stats')
    const stats = parseRedisInfo(info)
    return stats.instantaneous_ops_per_sec || 0
  } catch (error) {
    return 0
  }
}

const warmupCache = async (userId) => {
  const warmupTasks = []
  
  // Warm up user data
  warmupTasks.push(
    redis.setex(`user:${userId}`, 3600, JSON.stringify({
      id: userId,
      status: 'active',
      lastWarmed: Date.now()
    }))
  )
  
  // Warm up popular searches
  warmupTasks.push(
    redis.setex(`popular_searches:all`, 3600, JSON.stringify([
      'technology', 'business', 'entertainment', 'sports'
    ]))
  )
  
  // Warm up system stats
  warmupTasks.push(
    redis.setex('system:stats', 300, JSON.stringify({
      activeUsers: Math.floor(Math.random() * 1000),
      totalRequests: Math.floor(Math.random() * 10000),
      timestamp: Date.now()
    }))
  )
  
  await Promise.all(warmupTasks)
  
  return {
    tasksCompleted: warmupTasks.length,
    warmedKeys: ['user data', 'popular searches', 'system stats']
  }
}

const analyzeCacheUsage = async () => {
  const analysis = {
    topKeys: [],
    keyDistribution: {},
    expirationAnalysis: {},
    recommendations: []
  }
  
  // Get sample of keys for analysis
  const sampleKeys = await redis.randomkey()
  if (sampleKeys) {
    // Analyze key patterns
    const keyParts = sampleKeys.split(':')
    keyParts.forEach(part => {
      analysis.keyDistribution[part] = (analysis.keyDistribution[part] || 0) + 1
    })
  }
  
  // Mock recommendations
  analysis.recommendations = [
    'Consider increasing TTL for user session data',
    'Implement cache warming for popular content',
    'Review key naming conventions for better organization'
  ]
  
  return analysis
}

const formatBytes = (bytes) => {
  if (bytes === 0) return '0 B'
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
}

// Advanced Security & Audit API
app.get('/api/security/audit',
  strictRateLimit,
  authenticateJWT,
  [
    body('startDate').optional().isISO8601(),
    body('endDate').optional().isISO8601(),
    body('severity').optional().isIn(['low', 'medium', 'high', 'critical']),
    body('category').optional().isIn(['authentication', 'authorization', 'data_access', 'configuration', 'network'])
  ],
  validateRequest,
  async (req, res) => {
    try {
      const {
        startDate = moment().subtract(30, 'days').toISOString(),
        endDate = moment().toISOString(),
        severity = null,
        category = null,
        exportFormat = null
      } = req.query

      const userId = req.user.id

      // Check audit access permissions
      if (!req.user.permissions?.security?.auditAccess) {
        return res.status(403).json({ error: 'Insufficient permissions for security audit' })
      }

      const auditData = {
        overview: {},
        activities: [],
        threats: [],
        compliance: {},
        recommendations: []
      }

      // Security activities analysis
      const securityActivities = await prisma.activity.findMany({
        where: {
          userId: req.user.permissions?.security?.auditAll ? undefined : userId,
          timestamp: {
            gte: new Date(startDate),
            lte: new Date(endDate)
          },
          action: {
            in: [
              'LOGIN_SUCCESS', 'LOGIN_FAILED', 'PASSWORD_CHANGED', 'ACCOUNT_LOCKED',
              'SUSPICIOUS_ACTIVITY', 'DATA_EXPORTED', 'PERMISSION_CHANGED',
              'API_KEY_CREATED', 'API_KEY_DELETED', 'WEBHOOK_FAILED'
            ]
          }
        },
        orderBy: { timestamp: 'desc' },
        take: 1000
      })

      // Categorize security events
      const eventCategories = {
        authentication: ['LOGIN_SUCCESS', 'LOGIN_FAILED', 'PASSWORD_CHANGED', 'ACCOUNT_LOCKED'],
        authorization: ['PERMISSION_CHANGED', 'UNAUTHORIZED_ACCESS'],
        data_access: ['DATA_EXPORTED', 'SENSITIVE_DATA_ACCESSED'],
        configuration: ['API_KEY_CREATED', 'API_KEY_DELETED', 'WEBHOOK_FAILED'],
        network: ['SUSPICIOUS_IP', 'RATE_LIMIT_EXCEEDED']
      }

      auditData.activities = securityActivities.map(activity => {
        const details = JSON.parse(activity.details || '{}')
        const activityCategory = Object.entries(eventCategories)
          .find(([_, actions]) => actions.includes(activity.action))?.[0] || 'other'
        
        return {
          id: activity.id,
          timestamp: activity.timestamp,
          action: activity.action,
          category: activityCategory,
          severity: determineSeverity(activity.action, details),
          userId: activity.userId,
          ipAddress: activity.ipAddress,
          location: activity.location,
          details: details,
          riskScore: calculateRiskScore(activity.action, details)
        }
      })

      // Filter by severity and category if specified
      if (severity) {
        auditData.activities = auditData.activities.filter(a => a.severity === severity)
      }
      if (category) {
        auditData.activities = auditData.activities.filter(a => a.category === category)
      }

      // Generate overview statistics
      auditData.overview = {
        totalEvents: auditData.activities.length,
        severityBreakdown: auditData.activities.reduce((acc, activity) => {
          acc[activity.severity] = (acc[activity.severity] || 0) + 1
          return acc
        }, {}),
        categoryBreakdown: auditData.activities.reduce((acc, activity) => {
          acc[activity.category] = (acc[activity.category] || 0) + 1
          return acc
        }, {}),
        riskScore: auditData.activities.reduce((sum, a) => sum + a.riskScore, 0) / auditData.activities.length || 0,
        timeRange: { startDate, endDate }
      }

      // Identify potential security threats
      auditData.threats = identifySecurityThreats(auditData.activities)

      // Compliance check
      auditData.compliance = await performComplianceCheck(userId, new Date(startDate), new Date(endDate))

      // Generate security recommendations
      auditData.recommendations = generateSecurityRecommendations(auditData.activities, auditData.threats)

      // Export functionality
      if (exportFormat) {
        const exportData = await generateSecurityReport(auditData, exportFormat)
        const filename = `security-audit-${moment().format('YYYY-MM-DD')}.${exportFormat}`
        
        // Store audit export
        await prisma.export.create({
          data: {
            userId,
            type: 'security_audit',
            format: exportFormat,
            filename,
            size: Buffer.byteLength(JSON.stringify(exportData)),
            parameters: JSON.stringify({ startDate, endDate, severity, category }),
            createdAt: new Date()
          }
        })

        const contentType = exportFormat === 'pdf' ? 'application/pdf' : 
                           exportFormat === 'xlsx' ? 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' :
                           'application/json'

        res.setHeader('Content-Type', contentType)
        res.setHeader('Content-Disposition', `attachment; filename=${filename}`)
        return res.send(exportData)
      }

      // Log audit access
      await logActivity(userId, 'SECURITY_AUDIT_ACCESSED', {
        dateRange: { startDate, endDate },
        filters: { severity, category },
        eventCount: auditData.activities.length,
        ipAddress: req.ip
      })

      // Process analytics
      await processAnalytics(userId, 'security_audit', {
        eventCount: auditData.activities.length,
        threatCount: auditData.threats.length,
        riskScore: auditData.overview.riskScore
      })

      res.json({
        success: true,
        audit: auditData,
        meta: {
          generatedAt: new Date().toISOString(),
          filters: { startDate, endDate, severity, category }
        }
      })

    } catch (error) {
      logger.error('Security audit error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Security audit failed' })
    }
  }
)

// Security helper functions
const determineSeverity = (action, details) => {
  const severityMap = {
    'LOGIN_FAILED': details.consecutiveFailures > 5 ? 'high' : 'medium',
    'ACCOUNT_LOCKED': 'high',
    'SUSPICIOUS_ACTIVITY': 'critical',
    'PASSWORD_CHANGED': 'medium',
    'DATA_EXPORTED': 'medium',
    'UNAUTHORIZED_ACCESS': 'high',
    'API_KEY_CREATED': 'low',
    'API_KEY_DELETED': 'medium',
    'WEBHOOK_FAILED': 'low',
    'PERMISSION_CHANGED': 'medium'
  }
  
  return severityMap[action] || 'low'
}

const calculateRiskScore = (action, details) => {
  const baseScores = {
    'LOGIN_FAILED': 3,
    'ACCOUNT_LOCKED': 8,
    'SUSPICIOUS_ACTIVITY': 10,
    'PASSWORD_CHANGED': 2,
    'DATA_EXPORTED': 5,
    'UNAUTHORIZED_ACCESS': 9,
    'API_KEY_CREATED': 1,
    'API_KEY_DELETED': 3,
    'WEBHOOK_FAILED': 1,
    'PERMISSION_CHANGED': 4
  }
  
  let score = baseScores[action] || 1
  
  // Adjust score based on details
  if (details.foreignIP) score += 2
  if (details.unusualTime) score += 1
  if (details.multipleAttempts) score += 3
  if (details.sensitiveData) score += 4
  
  return Math.min(score, 10) // Cap at 10
}

const identifySecurityThreats = (activities) => {
  const threats = []
  
  // Brute force detection
  const failedLogins = activities.filter(a => a.action === 'LOGIN_FAILED')
  if (failedLogins.length > 10) {
    threats.push({
      type: 'brute_force',
      severity: 'high',
      description: `${failedLogins.length} failed login attempts detected`,
      affectedIPs: [...new Set(failedLogins.map(a => a.ipAddress))],
      timeframe: {
        start: Math.min(...failedLogins.map(a => new Date(a.timestamp))),
        end: Math.max(...failedLogins.map(a => new Date(a.timestamp)))
      }
    })
  }
  
  // Unusual access patterns
  const accessByIP = {}
  activities.forEach(activity => {
    const ip = activity.ipAddress
    if (!accessByIP[ip]) accessByIP[ip] = []
    accessByIP[ip].push(activity)
  })
  import express from 'express'
import jwt from 'jsonwebtoken'
import bcrypt from 'bcryptjs'
import multer from 'multer'
import sharp from 'sharp'
import nodemailer from 'nodemailer'
import rateLimit from 'express-rate-limit'
import helmet from 'helmet'
import cors from 'cors'
import { body, param, validationResult } from 'express-validator'
import { PrismaClient } from '@prisma/client'
import Redis from 'ioredis'
import AWS from 'aws-sdk'
import { v4 as uuidv4 } from 'uuid'
import crypto from 'crypto'
import { promisify } from 'util'
import fs from 'fs/promises'
import path from 'path'
import FormData from 'form-data'
import axios from 'axios'
import moment from 'moment'
import validator from 'validator'
import speakeasy from 'speakeasy'
import qrcode from 'qrcode'
import geoip from 'geoip-lite'
import useragent from 'useragent'
import winston from 'winston'
import compression from 'compression'
import cookieParser from 'cookie-parser'
import session from 'express-session'
import MongoStore from 'connect-mongo'
import passport from 'passport'
import { Readable } from 'stream'
import csvParser from 'csv-parser'
import ExcelJS from 'exceljs'
import PDFDocument from 'pdfkit'
import archiver from 'archiver'
import cheerio from 'cheerio'
import puppeteer from 'puppeteer'
import cron from 'node-cron'
import webpush from 'web-push'
import socketio from 'socket.io'
import amqp from 'amqplib'
import Stripe from 'stripe'
import Twilio from 'twilio'
import SendGrid from '@sendgrid/mail'
import CloudFlare from 'cloudflare'
import Sentry from '@sentry/node'
import DataLoader from 'dataloader'
import { GraphQLSchema, GraphQLObjectType, GraphQLString, GraphQLInt, GraphQLList, GraphQLNonNull, GraphQLBoolean, GraphQLFloat } from 'graphql'

const app = express()
const router = express.Router()

// Initialize services
const prisma = new PrismaClient()
const redis = new Redis(process.env.REDIS_URL)
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY)
const twilio = Twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN)
const cloudflare = new CloudFlare({ email: process.env.CLOUDFLARE_EMAIL, key: process.env.CLOUDFLARE_API_KEY })

SendGrid.setApiKey(process.env.SENDGRID_API_KEY)

// AWS Services
const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION
})

const ses = new AWS.SES({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_SES_REGION
})

const dynamodb = new AWS.DynamoDB.DocumentClient({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION
})

const sns = new AWS.SNS({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION
})

const sqs = new AWS.SQS({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION
})

// Web Push Configuration
webpush.setVapidDetails(
  'mailto:' + process.env.WEB_PUSH_EMAIL,
  process.env.WEB_PUSH_PUBLIC_KEY,
  process.env.WEB_PUSH_PRIVATE_KEY
)

// Winston Logger Configuration
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
})

// DataLoader for efficient database queries
const userLoader = new DataLoader(async (userIds) => {
  const users = await prisma.user.findMany({
    where: { id: { in: userIds } },
    include: {
      profile: true,
      permissions: true,
      subscriptions: true,
      activities: true,
      notifications: true,
      sessions: true,
      devices: true,
      socialAccounts: true,
      paymentMethods: true,
      transactions: true,
      analytics: true,
      preferences: true
    }
  })
  return userIds.map(id => users.find(user => user.id === id))
})

// Multer configuration for file uploads
const storage = multer.memoryStorage()
const upload = multer({ 
  storage,
  limits: { 
    fileSize: 50 * 1024 * 1024, // 50MB
    files: 10 
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'application/pdf', 'text/csv', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet']
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true)
    } else {
      cb(new Error('Invalid file type'), false)
    }
  }
})

// Rate limiting
const createRateLimit = (windowMs, max, message) => rateLimit({
  windowMs,
  max,
  message: { error: message },
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req) => {
    return req.ip + ':' + (req.user?.id || 'anonymous')
  }
})

const strictRateLimit = createRateLimit(15 * 60 * 1000, 100, 'Too many requests')
const loginRateLimit = createRateLimit(15 * 60 * 1000, 5, 'Too many login attempts')
const uploadRateLimit = createRateLimit(60 * 60 * 1000, 20, 'Too many upload requests')

// Middleware setup
app.use(helmet())
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept', 'Origin']
}))
app.use(compression())
app.use(express.json({ limit: '10mb' }))
app.use(express.urlencoded({ extended: true, limit: '10mb' }))
app.use(cookieParser())

// Session configuration
app.use(session({
  secret: process.env.SESSION_SECRET || 'fallback-secret',
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({
    mongoUrl: process.env.MONGODB_URL
  }),
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000 // 24 hours
  }
}))

// Passport initialization
app.use(passport.initialize())
app.use(passport.session())

// Authentication middleware
const authenticateJWT = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization
    const token = authHeader && authHeader.split(' ')[1]

    if (!token) {
      return res.status(401).json({ error: 'Access token required' })
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET)
    const user = await userLoader.load(decoded.userId)

    if (!user || !user.isActive) {
      return res.status(401).json({ error: 'Invalid or inactive user' })
    }

    // Check if session exists in Redis
    const session = await redis.get(`session:${decoded.sessionId}`)
    if (!session) {
      return res.status(401).json({ error: 'Session expired' })
    }

    req.user = user
    req.sessionId = decoded.sessionId
    next()
  } catch (error) {
    logger.error('Authentication error:', error)
    return res.status(401).json({ error: 'Invalid token' })
  }
}

// Validation middleware
const validateRequest = (req, res, next) => {
  const errors = validationResult(req)
  if (!errors.isEmpty()) {
    return res.status(400).json({
      error: 'Validation failed',
      details: errors.array()
    })
  }
  next()
}

// Device fingerprinting and security
const generateDeviceFingerprint = (req) => {
  const agent = useragent.parse(req.headers['user-agent'])
  const geo = geoip.lookup(req.ip)
  
  return crypto.createHash('sha256')
    .update(`${agent.family}-${agent.os.family}-${req.ip}-${geo?.country || 'unknown'}`)
    .digest('hex')
}

// Audit logging
const logActivity = async (userId, action, details = {}) => {
  try {
    await prisma.activity.create({
      data: {
        userId,
        action,
        details: JSON.stringify(details),
        timestamp: new Date(),
        ipAddress: details.ipAddress,
        userAgent: details.userAgent,
        location: details.location
      }
    })

    // Store in DynamoDB for analytics
    await dynamodb.put({
      TableName: 'UserActivities',
      Item: {
        id: uuidv4(),
        userId,
        action,
        timestamp: Date.now(),
        details
      }
    }).promise()
  } catch (error) {
    logger.error('Activity logging error:', error)
  }
}

// Message queue for background processing
let rabbitmqConnection = null
let rabbitmqChannel = null

const initializeMessageQueue = async () => {
  try {
    rabbitmqConnection = await amqp.connect(process.env.RABBITMQ_URL || 'amqp://localhost')
    rabbitmqChannel = await rabbitmqConnection.createChannel()
    
    await rabbitmqChannel.assertQueue('email_queue', { durable: true })
    await rabbitmqChannel.assertQueue('analytics_queue', { durable: true })
    await rabbitmqChannel.assertQueue('notification_queue', { durable: true })
    
    logger.info('RabbitMQ initialized successfully')
  } catch (error) {
    logger.error('RabbitMQ initialization failed:', error)
  }
}

// Initialize message queue
initializeMessageQueue()

// Email service
const sendEmail = async (to, subject, html, attachments = []) => {
  try {
    const msg = {
      to,
      from: process.env.FROM_EMAIL,
      subject,
      html,
      attachments
    }

    if (process.env.USE_SENDGRID === 'true') {
      await SendGrid.send(msg)
    } else {
      // Use AWS SES
      const sesParams = {
        Destination: { ToAddresses: [to] },
        Message: {
          Body: { Html: { Charset: 'UTF-8', Data: html } },
          Subject: { Charset: 'UTF-8', Data: subject }
        },
        Source: process.env.FROM_EMAIL
      }
      await ses.sendEmail(sesParams).promise()
    }

    logger.info(`Email sent to ${to}`)
  } catch (error) {
    logger.error('Email sending error:', error)
    throw error
  }
}

// Push notification service
const sendPushNotification = async (subscription, payload) => {
  try {
    await webpush.sendNotification(subscription, JSON.stringify(payload))
    logger.info('Push notification sent successfully')
  } catch (error) {
    logger.error('Push notification error:', error)
    throw error
  }
}

// File processing utilities
const processImage = async (buffer, options = {}) => {
  try {
    const { width = 800, height = 600, quality = 80, format = 'jpeg' } = options
    
    return await sharp(buffer)
      .resize(width, height, { fit: 'inside', withoutEnlargement: true })
      .toFormat(format, { quality })
      .toBuffer()
  } catch (error) {
    logger.error('Image processing error:', error)
    throw error
  }
}

const uploadToS3 = async (buffer, key, contentType) => {
  try {
    const params = {
      Bucket: process.env.AWS_S3_BUCKET,
      Key: key,
      Body: buffer,
      ContentType: contentType,
      ACL: 'public-read'
    }

    const result = await s3.upload(params).promise()
    return result.Location
  } catch (error) {
    logger.error('S3 upload error:', error)
    throw error
  }
}

// CSV/Excel processing
const processCSV = async (buffer) => {
  return new Promise((resolve, reject) => {
    const results = []
    const stream = Readable.from(buffer.toString())
    
    stream
      .pipe(csvParser())
      .on('data', (data) => results.push(data))
      .on('end', () => resolve(results))
      .on('error', reject)
  })
}

const processExcel = async (buffer) => {
  try {
    const workbook = new ExcelJS.Workbook()
    await workbook.xlsx.load(buffer)
    
    const worksheet = workbook.getWorksheet(1)
    const data = []
    
    worksheet.eachRow((row, rowNumber) => {
      if (rowNumber > 1) { // Skip header
        data.push(row.values)
      }
    })
    
    return data
  } catch (error) {
    logger.error('Excel processing error:', error)
    throw error
  }
}

// PDF generation
const generatePDF = async (data) => {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument()
      const chunks = []
      
      doc.on('data', chunk => chunks.push(chunk))
      doc.on('end', () => resolve(Buffer.concat(chunks)))
      doc.on('error', reject)
      
      // Add content to PDF
      doc.fontSize(20).text('User Analytics Report', 100, 100)
      doc.fontSize(12).text(`Generated on: ${moment().format('YYYY-MM-DD HH:mm:ss')}`, 100, 130)
      
      let yPosition = 160
      Object.entries(data).forEach(([key, value]) => {
        doc.text(`${key}: ${value}`, 100, yPosition)
        yPosition += 20
      })
      
      doc.end()
    } catch (error) {
      reject(error)
    }
  })
}

// Analytics processing
const processAnalytics = async (userId, eventType, eventData) => {
  try {
    // Store in Redis for real-time analytics
    const key = `analytics:${userId}:${moment().format('YYYY-MM-DD')}`
    await redis.hincrby(key, eventType, 1)
    await redis.expire(key, 7 * 24 * 60 * 60) // 7 days TTL

    // Store in DynamoDB for long-term storage
    await dynamodb.put({
      TableName: 'UserAnalytics',
      Item: {
        id: uuidv4(),
        userId,
        eventType,
        eventData,
        timestamp: Date.now(),
        date: moment().format('YYYY-MM-DD'),
        hour: moment().hour()
      }
    }).promise()

    // Send to analytics queue for further processing
    if (rabbitmqChannel) {
      await rabbitmqChannel.sendToQueue(
        'analytics_queue',
        Buffer.from(JSON.stringify({ userId, eventType, eventData, timestamp: Date.now() })),
        { persistent: true }
      )
    }
  } catch (error) {
    logger.error('Analytics processing error:', error)
  }
}

// Web scraping utility
const scrapeWebsite = async (url) => {
  let browser = null
  try {
    browser = await puppeteer.launch({ headless: true })
    const page = await browser.newPage()
    
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36')
    await page.goto(url, { waitUntil: 'networkidle2' })
    
    const content = await page.evaluate(() => {
      return {
        title: document.title,
        description: document.querySelector('meta[name="description"]')?.content || '',
        text: document.body.innerText.slice(0, 1000) // First 1000 chars
      }
    })
    
    return content
  } catch (error) {
    logger.error('Web scraping error:', error)
    throw error
  } finally {
    if (browser) await browser.close()
  }
}

// Payment processing
const processPayment = async (amount, currency, paymentMethodId, customerId) => {
  try {
    const paymentIntent = await stripe.paymentIntents.create({
      amount: amount * 100, // Convert to cents
      currency,
      payment_method: paymentMethodId,
      customer: customerId,
      confirm: true,
      automatic_payment_methods: { enabled: true, allow_redirects: 'never' }
    })

    return paymentIntent
  } catch (error) {
    logger.error('Payment processing error:', error)
    throw error
  }
}

// Two-Factor Authentication
const generate2FA = () => {
  const secret = speakeasy.generateSecret({
    name: 'YourApp',
    length: 32
  })
  
  return {
    secret: secret.base32,
    qrCode: qrcode.toDataURL(secret.otpauth_url)
  }
}

const verify2FA = (token, secret) => {
  return speakeasy.totp.verify({
    secret,
    encoding: 'base32',
    token,
    window: 2
  })
}

// MAIN API ROUTES

// Complex User Registration with Multiple Features
app.post('/api/users/register',
  strictRateLimit,
  upload.single('avatar'),
  [
    body('email').isEmail().normalizeEmail(),
    body('password').isLength({ min: 8 }).matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/),
    body('firstName').trim().isLength({ min: 2, max: 50 }),
    body('lastName').trim().isLength({ min: 2, max: 50 }),
    body('phoneNumber').optional().isMobilePhone(),
    body('dateOfBirth').optional().isISO8601(),
    body('termsAccepted').isBoolean().equals('true')
  ],
  validateRequest,
  async (req, res) => {
    try {
      const {
        email,
        password,
        firstName,
        lastName,
        phoneNumber,
        dateOfBirth,
        preferences = {},
        marketingOptIn = false
      } = req.body

      // Check if user already exists
      const existingUser = await prisma.user.findUnique({ where: { email } })
      if (existingUser) {
        return res.status(400).json({ error: 'User already exists' })
      }

      // Hash password
      const saltRounds = 12
      const hashedPassword = await bcrypt.hash(password, saltRounds)

      // Generate verification token
      const verificationToken = crypto.randomBytes(32).toString('hex')

      // Process avatar upload if provided
      let avatarUrl = null
      if (req.file) {
        const processedImage = await processImage(req.file.buffer, {
          width: 300,
          height: 300,
          quality: 85,
          format: 'jpeg'
        })
        
        const avatarKey = `avatars/${uuidv4()}.jpg`
        avatarUrl = await uploadToS3(processedImage, avatarKey, 'image/jpeg')
      }

      // Get device fingerprint and geo location
      const deviceFingerprint = generateDeviceFingerprint(req)
      const geo = geoip.lookup(req.ip)
      const agent = useragent.parse(req.headers['user-agent'])

      // Generate 2FA secret
      const twoFactorSecret = generate2FA()

      // Create user with related data
      const user = await prisma.$transaction(async (tx) => {
        const newUser = await tx.user.create({
          data: {
            email,
            password: hashedPassword,
            firstName,
            lastName,
            phoneNumber,
            dateOfBirth: dateOfBirth ? new Date(dateOfBirth) : null,
            avatarUrl,
            isActive: false,
            emailVerified: false,
            verificationToken,
            twoFactorSecret: twoFactorSecret.secret,
            marketingOptIn,
            registrationIp: req.ip,
            lastLoginIp: req.ip,
            deviceFingerprint,
            profile: {
              create: {
                bio: '',
                location: geo ? `${geo.city}, ${geo.country}` : null,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                language: 'en',
                theme: 'light'
              }
            },
            preferences: {
              create: {
                notifications: preferences.notifications || {
                  email: true,
                  push: true,
                  sms: false,
                  marketing: marketingOptIn
                },
                privacy: preferences.privacy || {
                  profileVisibility: 'public',
                  activityVisibility: 'friends',
                  searchable: true
                },
                display: preferences.display || {
                  theme: 'light',
                  language: 'en',
                  timezone: 'UTC'
                }
              }
            },
            analytics: {
              create: {
                registrationDate: new Date(),
                registrationSource: req.headers.referer || 'direct',
                deviceType: agent.device.family || 'desktop',
                browser: agent.family,
                os: agent.os.family,
                country: geo?.country,
                city: geo?.city,
                totalLogins: 0,
                lastActivity: new Date()
              }
            }
          },
          include: {
            profile: true,
            preferences: true,
            analytics: true
          }
        })

        // Create initial subscription (free tier)
        await tx.subscription.create({
          data: {
            userId: newUser.id,
            plan: 'free',
            status: 'active',
            startDate: new Date(),
            features: JSON.stringify({
              maxStorage: '1GB',
              maxApiCalls: 1000,
              supportLevel: 'basic'
            })
          }
        })

        return newUser
      })

      // Generate QR code for 2FA
      const qrCodeDataUrl = await qrcode.toDataURL(twoFactorSecret.qrCode)

      // Send verification email
      const verificationUrl = `${process.env.FRONTEND_URL}/verify-email?token=${verificationToken}`
      const emailHtml = `
        <h1>Welcome to YourApp!</h1>
        <p>Please verify your email address by clicking the link below:</p>
        <a href="${verificationUrl}">Verify Email</a>
        <p>This link will expire in 24 hours.</p>
      `

      // Queue email for sending
      if (rabbitmqChannel) {
        await rabbitmqChannel.sendToQueue(
          'email_queue',
          Buffer.from(JSON.stringify({
            to: email,
            subject: 'Welcome to YourApp - Verify Your Email',
            html: emailHtml,
            priority: 'high'
          })),
          { persistent: true }
        )
      }

      // Log registration activity
      await logActivity(user.id, 'USER_REGISTERED', {
        ipAddress: req.ip,
        userAgent: req.headers['user-agent'],
        location: geo ? `${geo.city}, ${geo.country}` : null,
        deviceFingerprint
      })

      // Process analytics
      await processAnalytics(user.id, 'registration', {
        source: req.headers.referer || 'direct',
        deviceType: agent.device.family || 'desktop',
        browser: agent.family,
        os: agent.os.family
      })

      // Send welcome SMS if phone number provided
      if (phoneNumber) {
        try {
          await twilio.messages.create({
            body: `Welcome to YourApp! Your account has been created successfully. Please verify your email to complete registration.`,
            from: process.env.TWILIO_PHONE_NUMBER,
            to: phoneNumber
          })
        } catch (smsError) {
          logger.error('SMS sending error:', smsError)
        }
      }

      // Create Stripe customer
      let stripeCustomerId = null
      try {
        const stripeCustomer = await stripe.customers.create({
          email,
          name: `${firstName} ${lastName}`,
          phone: phoneNumber,
          metadata: {
            userId: user.id
          }
        })
        stripeCustomerId = stripeCustomer.id

        // Update user with Stripe customer ID
        await prisma.user.update({
          where: { id: user.id },
          data: { stripeCustomerId }
        })
      } catch (stripeError) {
        logger.error('Stripe customer creation error:', stripeError)
      }

      // Set up CloudFlare DNS record for custom subdomain (if premium feature)
      if (preferences.customSubdomain) {
        try {
          await cloudflare.dnsRecords.add(process.env.CLOUDFLARE_ZONE_ID, {
            type: 'CNAME',
            name: preferences.customSubdomain,
            content: process.env.MAIN_DOMAIN,
            ttl: 1
          })
        } catch (cfError) {
          logger.error('CloudFlare DNS error:', cfError)
        }
      }

      // Cache user data in Redis
      await redis.setex(`user:${user.id}`, 3600, JSON.stringify({
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        isActive: user.isActive,
        emailVerified: user.emailVerified
      }))

      // Response (exclude sensitive data)
      const { password: _, verificationToken: __, twoFactorSecret: ___, ...safeUserData } = user

      res.status(201).json({
        success: true,
        message: 'User registered successfully. Please check your email for verification.',
        user: safeUserData,
        twoFactorQR: qrCodeDataUrl,
        stripeCustomerId
      })

    } catch (error) {
      logger.error('Registration error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Registration failed' })
    }
  }
)

// Complex User Login with Multiple Security Features
app.post('/api/users/login',
  loginRateLimit,
  [
    body('email').isEmail().normalizeEmail(),
    body('password').notEmpty(),
    body('twoFactorToken').optional().isLength({ min: 6, max: 6 }),
    body('deviceTrust').optional().isBoolean()
  ],
  validateRequest,
  async (req, res) => {
    try {
      const { email, password, twoFactorToken, deviceTrust = false } = req.body

      // Find user with related data
      const user = await prisma.user.findUnique({
        where: { email },
        include: {
          profile: true,
          preferences: true,
          sessions: true,
          devices: true,
          analytics: true
        }
      })

      if (!user) {
        return res.status(401).json({ error: 'Invalid credentials' })
      }

      if (!user.isActive) {
        return res.status(401).json({ error: 'Account is inactive' })
      }

      // Verify password
      const isValidPassword = await bcrypt.compare(password, user.password)
      if (!isValidPassword) {
        await logActivity(user.id, 'LOGIN_FAILED', {
          reason: 'invalid_password',
          ipAddress: req.ip,
          userAgent: req.headers['user-agent']
        })
        return res.status(401).json({ error: 'Invalid credentials' })
      }

      // Check if 2FA is enabled and verify token
      if (user.twoFactorEnabled && twoFactorToken) {
        const isValid2FA = verify2FA(twoFactorToken, user.twoFactorSecret)
        if (!isValid2FA) {
          await logActivity(user.id, 'LOGIN_FAILED', {
            reason: 'invalid_2fa',
            ipAddress: req.ip,
            userAgent: req.headers['user-agent']
          })
          return res.status(401).json({ error: 'Invalid 2FA token' })
        }
      } else if (user.twoFactorEnabled && !twoFactorToken) {
        return res.status(401).json({ 
          error: '2FA token required',
          requiresTwoFactor: true 
        })
      }

      // Device fingerprinting and trust
      const deviceFingerprint = generateDeviceFingerprint(req)
      const geo = geoip.lookup(req.ip)
      const agent = useragent.parse(req.headers['user-agent'])

      // Check if device is trusted
      const trustedDevice = await prisma.device.findFirst({
        where: {
          userId: user.id,
          fingerprint: deviceFingerprint,
          trusted: true
        }
      })

      // If new device and 2FA not provided, require it
      if (!trustedDevice && !twoFactorToken && user.twoFactorEnabled) {
        // Send notification about new device login attempt
        const emailHtml = `
          <h2>New Device Login Attempt</h2>
          <p>Someone attempted to login to your account from a new device:</p>
          <p><strong>IP Address:</strong> ${req.ip}</p>
          <p><strong>Location:</strong> ${geo ? `${geo.city}, ${geo.country}` : 'Unknown'}</p>
          <p><strong>Device:</strong> ${agent.family} on ${agent.os.family}</p>
          <p><strong>Time:</strong> ${new Date().toISOString()}</p>
          <p>If this was you, please use your 2FA token to complete login. If not, please secure your account immediately.</p>
        `

        if (rabbitmqChannel) {
          await rabbitmqChannel.sendToQueue(
            'email_queue',
            Buffer.from(JSON.stringify({
              to: email,
              subject: 'New Device Login Attempt',
              html: emailHtml,
              priority: 'high'
            })),
            { persistent: true }
          )
        }

        return res.status(401).json({ 
          error: 'New device detected. 2FA required.',
          requiresTwoFactor: true,
          newDevice: true
        })
      }

      // Create session
      const sessionId = uuidv4()
      const sessionToken = jwt.sign(
        { 
          userId: user.id, 
          sessionId,
          deviceFingerprint 
        },
        process.env.JWT_SECRET,
        { 
          expiresIn: deviceTrust ? '30d' : '7d',
          issuer: 'yourapp',
          audience: 'yourapp-users'
        }
      )

      // Store session in Redis
      const sessionData = {
        userId: user.id,
        deviceFingerprint,
        ipAddress: req.ip,
        userAgent: req.headers['user-agent'],
        location: geo ? `${geo.city}, ${geo.country}` : null,
        loginTime: Date.now(),
        trusted: deviceTrust || !!trustedDevice
      }

      await redis.setex(
        `session:${sessionId}`,
        deviceTrust ? 30 * 24 * 60 * 60 : 7 * 24 * 60 * 60, // 30 days or 7 days
        JSON.stringify(sessionData)
      )

      // Store session in database
      await prisma.session.create({
        data: {
          id: sessionId,
          userId: user.id,
          token: sessionToken,
          deviceFingerprint,
          ipAddress: req.ip,
          userAgent: req.headers['user-agent'],
          location: geo ? `${geo.city}, ${geo.country}` : null,
          trusted: deviceTrust || !!trustedDevice,
          expiresAt: new Date(Date.now() + (deviceTrust ? 30 : 7) * 24 * 60 * 60 * 1000)
        }
      })

      // Register or update device
      if (!trustedDevice) {
        await prisma.device.upsert({
          where: {
            userId_fingerprint: {
              userId: user.id,
              fingerprint: deviceFingerprint
            }
          },
          update: {
            lastSeen: new Date(),
            ipAddress: req.ip,
            location: geo ? `${geo.city}, ${geo.country}` : null
          },
          create: {
            userId: user.id,
            fingerprint: deviceFingerprint,
            deviceName: `${agent.family} on ${agent.os.family}`,
            deviceType: agent.device.family || 'desktop',
            trusted: deviceTrust,
            ipAddress: req.ip,
            location: geo ? `${geo.city}, ${geo.country}` : null,
            lastSeen: new Date()
          }
        })
      }

      // Update user analytics and last login
      await prisma.$transaction([
        prisma.user.update({
          where: { id: user.id },
          data: {
            lastLoginAt: new Date(),
            lastLoginIp: req.ip,
            loginCount: { increment: 1 }
          }
        }),
        prisma.userAnalytics.update({
          where: { userId: user.id },
          data: {
            totalLogins: { increment: 1 },
            lastActivity: new Date(),
            lastLoginCountry: geo?.country,
            lastLoginCity: geo?.city
          }
        })
      ])

      // Process login analytics
      await processAnalytics(user.id, 'login', {
        deviceType: agent.device.family || 'desktop',
        browser: agent.family,
        os: agent.os.family,
        country: geo?.country,
        city: geo?.city,
        trusted: deviceTrust || !!trustedDevice
      })

      // Log successful login
      await logActivity(user.id, 'LOGIN_SUCCESS', {
        ipAddress: req.ip,
        userAgent: req.headers['user-agent'],
        location: geo ? `${geo.city}, ${geo.country}` : null,
        deviceFingerprint,
        sessionId
      })

      // Update last activity in cache
      await redis.setex(`user:${user.id}`, 3600, JSON.stringify({
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        isActive: user.isActive,
        emailVerified: user.emailVerified,
        lastActivity: Date.now()
      }))

      // Send login notification if enabled
      if (user.preferences?.notifications?.email && !trustedDevice) {
        const loginNotificationHtml = `
          <h2>New Login to Your Account</h2>
          <p>Your account was accessed from:</p>
          <p><strong>IP Address:</strong> ${req.ip}</p>
          <p><strong>Location:</strong> ${geo ? `${geo.city}, ${geo.country}` : 'Unknown'}</p>
          <p><strong>Device:</strong> ${agent.family} on ${agent.os.family}</p>
          <p><strong>Time:</strong> ${new Date().toISOString()}</p>
          <p>If this wasn't you, please secure your account immediately.</p>
        `

        if (rabbitmqChannel) {
          await rabbitmqChannel.sendToQueue(
            'email_queue',
            Buffer.from(JSON.stringify({
              to: email,
              subject: 'New Login to Your Account',
              html: loginNotificationHtml,
              priority: 'normal'
            })),
            { persistent: true }
          )
        }
      }

      // Send push notification for mobile login
      if (user.preferences?.notifications?.push) {
        const pushSubscriptions = await prisma.pushSubscription.findMany({
          where: { userId: user.id, active: true }
        })

        for (const subscription of pushSubscriptions) {
          try {
            await sendPushNotification(JSON.parse(subscription.subscription), {
              title: 'New Login',
              body: `Login from ${geo ? `${geo.city}, ${geo.country}` : 'unknown location'}`,
              icon: '/icon-192x192.png',
              badge: '/badge-72x72.png',
              data: {
                type: 'login',
                timestamp: Date.now()
              }
            })
          } catch (pushError) {
            logger.error('Push notification error:', pushError)
          }
        }
      }

      // Clean up old sessions (keep only last 5)
      const oldSessions = await prisma.session.findMany({
        where: { userId: user.id },
        orderBy: { createdAt: 'desc' },
        skip: 5
      })

      if (oldSessions.length > 0) {
        const oldSessionIds = oldSessions.map(s => s.id)
        await prisma.session.deleteMany({
          where: { id: { in: oldSessionIds } }
        })

        // Remove from Redis
        for (const oldSession of oldSessions) {
          await redis.del(`session:${oldSession.id}`)
        }
      }

      // Return success response
      const { password: _, verificationToken: __, twoFactorSecret: ___, ...safeUserData } = user

      res.json({
        success: true,
        message: 'Login successful',
        token: sessionToken,
        user: safeUserData,
        session: {
          id: sessionId,
          expiresAt: sessionData.loginTime + (deviceTrust ? 30 : 7) * 24 * 60 * 60 * 1000
        },
        newDevice: !trustedDevice
      })

    } catch (error) {
      logger.error('Login error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Login failed' })
    }
  }
)

// Complex User Profile Management with File Uploads and Analytics
app.put('/api/users/profile',
  strictRateLimit,
  authenticateJWT,
  upload.fields([
    { name: 'avatar', maxCount: 1 },
    { name: 'cover', maxCount: 1 },
    { name: 'documents', maxCount: 5 }
  ]),
  [
    body('firstName').optional().trim().isLength({ min: 2, max: 50 }),
    body('lastName').optional().trim().isLength({ min: 2, max: 50 }),
    body('bio').optional().isLength({ max: 500 }),
    body('website').optional().isURL(),
    body('location').optional().isLength({ max: 100 }),
    body('dateOfBirth').optional().isISO8601(),
    body('phoneNumber').optional().isMobilePhone(),
    body('socialLinks').optional().isJSON(),
    body('skills').optional().isJSON(),
    body('interests').optional().isJSON()
  ],
  validateRequest,
  async (req, res) => {
    try {
      const userId = req.user.id
      const {
        firstName,
        lastName,
        bio,
        website,
        location,
        dateOfBirth,
        phoneNumber,
        socialLinks = '{}',
        skills = '[]',
        interests = '[]',
        privacy = '{}'
      } = req.body

      const parsedSocialLinks = JSON.parse(socialLinks)
      const parsedSkills = JSON.parse(skills)
      const parsedInterests = JSON.parse(interests)
      const parsedPrivacy = JSON.parse(privacy)

      // Process uploaded files
      const uploadedFiles = {
        avatarUrl: null,
        coverUrl: null,
        documentUrls: []
      }

      if (req.files) {
        // Process avatar
        if (req.files.avatar && req.files.avatar[0]) {
          const avatarFile = req.files.avatar[0]
          const processedAvatar = await processImage(avatarFile.buffer, {
            width: 400,
            height: 400,
            quality: 90,
            format: 'jpeg'
          })
          
          const avatarKey = `avatars/${userId}/${uuidv4()}.jpg`
          uploadedFiles.avatarUrl = await uploadToS3(processedAvatar, avatarKey, 'image/jpeg')
        }

        // Process cover image
        if (req.files.cover && req.files.cover[0]) {
          const coverFile = req.files.cover[0]
          const processedCover = await processImage(coverFile.buffer, {
            width: 1200,
            height: 400,
            quality: 85,
            format: 'jpeg'
          })
          
          const coverKey = `covers/${userId}/${uuidv4()}.jpg`
          uploadedFiles.coverUrl = await uploadToS3(processedCover, coverKey, 'image/jpeg')
        }

        // Process documents
        if (req.files.documents) {
          for (const doc of req.files.documents) {
            const docKey = `documents/${userId}/${uuidv4()}-${doc.originalname}`
            const docUrl = await uploadToS3(doc.buffer, docKey, doc.mimetype)
            uploadedFiles.documentUrls.push({
              url: docUrl,
              name: doc.originalname,
              size: doc.size,
              type: doc.mimetype
            })
          }
        }
      }

      // Validate website URL by scraping
      let websiteData = null
      if (website) {
        try {
          websiteData = await scrapeWebsite(website)
        } catch (error) {
          logger.warn('Website scraping failed:', error)
        }
      }

      // Update user and profile data
      const updatedUser = await prisma.$transaction(async (tx) => {
        // Update user basic info
        const userUpdate = await tx.user.update({
          where: { id: userId },
          data: {
            firstName: firstName || undefined,
            lastName: lastName || undefined,
            phoneNumber: phoneNumber || undefined,
            dateOfBirth: dateOfBirth ? new Date(dateOfBirth) : undefined,
            avatarUrl: uploadedFiles.avatarUrl || undefined,
            website: website || undefined
          }
        })

        // Update or create profile
        const profileUpdate = await tx.profile.upsert({
          where: { userId },
          update: {
            bio: bio || undefined,
            location: location || undefined,
            coverImageUrl: uploadedFiles.coverUrl || undefined,
            socialLinks: parsedSocialLinks,
            skills: parsedSkills,
            interests: parsedInterests,
            websiteData: websiteData ? JSON.stringify(websiteData) : undefined,
            lastProfileUpdate: new Date()
          },
          create: {
            userId,
            bio: bio || '',
            location: location || '',
            coverImageUrl: uploadedFiles.coverUrl,
            socialLinks: parsedSocialLinks,
            skills: parsedSkills,
            interests: parsedInterests,
            websiteData: websiteData ? JSON.stringify(websiteData) : null,
            timezone: 'UTC',
            language: 'en',
            theme: 'light'
          }
        })

        // Update privacy settings
        if (Object.keys(parsedPrivacy).length > 0) {
          await tx.preferences.update({
            where: { userId },
            data: {
              privacy: {
                ...req.user.preferences?.privacy || {},
                ...parsedPrivacy
              }
            }
          })
        }

        // Store uploaded documents metadata
        if (uploadedFiles.documentUrls.length > 0) {
          for (const doc of uploadedFiles.documentUrls) {
            await tx.attachment.create({
              data: {
                userId,
                fileName: doc.name,
                fileUrl: doc.url,
                fileSize: doc.size,
                mimeType: doc.type,
                uploadDate: new Date()
              }
            })
          }
        }

        return { user: userUpdate, profile: profileUpdate }
      })

      // Update search index for user discovery
      const searchData = {
        userId,
        firstName: updatedUser.user.firstName,
        lastName: updatedUser.user.lastName,
        bio: updatedUser.profile.bio,
        skills: parsedSkills,
        interests: parsedInterests,
        location: updatedUser.profile.location,
        website: updatedUser.user.website
      }

      // Store in Redis for search
      await redis.setex(`search:user:${userId}`, 24 * 60 * 60, JSON.stringify(searchData))

      // Update analytics
      await processAnalytics(userId, 'profile_update', {
        fieldsUpdated: Object.keys(req.body),
        hasAvatar: !!uploadedFiles.avatarUrl,
        hasCover: !!uploadedFiles.coverUrl,
        documentCount: uploadedFiles.documentUrls.length,
        skillsCount: parsedSkills.length,
        interestsCount: parsedInterests.length
      })

      // Log activity
      await logActivity(userId, 'PROFILE_UPDATED', {
        fieldsUpdated: Object.keys(req.body),
        uploadedFiles: {
          avatar: !!uploadedFiles.avatarUrl,
          cover: !!uploadedFiles.coverUrl,
          documents: uploadedFiles.documentUrls.length
        },
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      })

      // Send notification to connections if major update
      const majorFields = ['firstName', 'lastName', 'bio', 'avatar']
      const hasMajorUpdate = majorFields.some(field => req.body[field] !== undefined || uploadedFiles.avatarUrl)

      if (hasMajorUpdate) {
        const connections = await prisma.connection.findMany({
          where: { 
            OR: [
              { userId, status: 'accepted' },
              { connectedUserId: userId, status: 'accepted' }
            ]
          },
          include: {
            user: true,
            connectedUser: true
          }
        })

        for (const connection of connections) {
          const connectedUser = connection.userId === userId ? connection.connectedUser : connection.user
          
          if (connectedUser.preferences?.notifications?.profileUpdates) {
            if (rabbitmqChannel) {
              await rabbitmqChannel.sendToQueue(
                'notification_queue',
                Buffer.from(JSON.stringify({
                  type: 'profile_update',
                  userId: connectedUser.id,
                  data: {
                    updatedUserId: userId,
                    updatedUserName: `${updatedUser.user.firstName} ${updatedUser.user.lastName}`,
                    updateType: 'profile'
                  }
                })),
                { persistent: true }
              )
            }
          }
        }
      }

      // Update cache
      await redis.setex(`user:${userId}`, 3600, JSON.stringify({
        id: userId,
        email: req.user.email,
        firstName: updatedUser.user.firstName,
        lastName: updatedUser.user.lastName,
        avatarUrl: updatedUser.user.avatarUrl,
        isActive: req.user.isActive,
        emailVerified: req.user.emailVerified,
        lastActivity: Date.now()
      }))

      res.json({
        success: true,
        message: 'Profile updated successfully',
        user: updatedUser.user,
        profile: updatedUser.profile,
        uploadedFiles: uploadedFiles.documentUrls.length > 0 ? uploadedFiles.documentUrls : undefined
      })

    } catch (error) {
      logger.error('Profile update error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Profile update failed' })
    }
  }
)

// Complex Analytics Dashboard with Data Export
app.get('/api/users/:userId/analytics',
  strictRateLimit,
  authenticateJWT,
  [
    param('userId').isUUID(),
    body('dateRange').optional().isIn(['7d', '30d', '90d', '1y', 'all']),
    body('metrics').optional().isJSON(),
    body('exportFormat').optional().isIn(['json', 'csv', 'xlsx', 'pdf'])
  ],
  validateRequest,
  async (req, res) => {
    try {
      const { userId } = req.params
      const { 
        dateRange = '30d', 
        metrics = '["all"]', 
        exportFormat = null,
        includeRealTime = false
      } = req.query

      // Check if user can access this analytics data
      if (userId !== req.user.id && !req.user.permissions?.analytics?.viewOthers) {
        return res.status(403).json({ error: 'Insufficient permissions' })
      }

      const parsedMetrics = JSON.parse(metrics)
      
      // Calculate date range
      const endDate = new Date()
      let startDate = new Date()
      
      switch (dateRange) {
        case '7d':
          startDate.setDate(endDate.getDate() - 7)
          break
        case '30d':
          startDate.setDate(endDate.getDate() - 30)
          break
        case '90d':
          startDate.setDate(endDate.getDate() - 90)
          break
        case '1y':
          startDate.setFullYear(endDate.getFullYear() - 1)
          break
        case 'all':
          startDate = new Date('2020-01-01')
          break
      }

      const analyticsData = {}

      // Get real-time data from Redis if requested
      if (includeRealTime) {
        const realtimeKeys = await redis.keys(`analytics:${userId}:*`)
        const realtimeData = {}
        
        for (const key of realtimeKeys) {
          const data = await redis.hgetall(key)
          const date = key.split(':')[2]
          realtimeData[date] = data
        }
        
        analyticsData.realtime = realtimeData
      }

      // Get database analytics
      if (parsedMetrics.includes('all') || parsedMetrics.includes('overview')) {
        const userAnalytics = await prisma.userAnalytics.findUnique({
          where: { userId }
        })
        analyticsData.overview = userAnalytics
      }

      // Get activity data
      if (parsedMetrics.includes('all') || parsedMetrics.includes('activities')) {
        const activities = await prisma.activity.findMany({
          where: {
            userId,
            timestamp: {
              gte: startDate,
              lte: endDate
            }
          },
          orderBy: { timestamp: 'desc' },
          take: 1000
        })

        // Group activities by type and date
        const activityStats = activities.reduce((acc, activity) => {
          const date = moment(activity.timestamp).format('YYYY-MM-DD')
          if (!acc[date]) acc[date] = {}
          if (!acc[date][activity.action]) acc[date][activity.action] = 0
          acc[date][activity.action]++
          return acc
        }, {})

        analyticsData.activities = {
          raw: activities,
          grouped: activityStats,
          total: activities.length
        }
      }

      // Get session data
      if (parsedMetrics.includes('all') || parsedMetrics.includes('sessions')) {
        const sessions = await prisma.session.findMany({
          where: {
            userId,
            createdAt: {
              gte: startDate,
              lte: endDate
            }
          },
          orderBy: { createdAt: 'desc' }
        })

        const sessionStats = {
          total: sessions.length,
          byDevice: sessions.reduce((acc, session) => {
            const deviceType = session.userAgent?.includes('Mobile') ? 'mobile' : 'desktop'
            acc[deviceType] = (acc[deviceType] || 0) + 1
            return acc
          }, {}),
          byLocation: sessions.reduce((acc, session) => {
            const location = session.location || 'Unknown'
            acc[location] = (acc[location] || 0) + 1
            return acc
          }, {}),
          averageDuration: sessions.length > 0 
            ? sessions.reduce((sum, session) => {
                const duration = session.lastActivity 
                  ? new Date(session.lastActivity) - new Date(session.createdAt)
                  : 0
                return sum + duration
              }, 0) / sessions.length
            : 0
        }

        analyticsData.sessions = sessionStats
      }

      // Get DynamoDB analytics data
      if (parsedMetrics.includes('all') || parsedMetrics.includes('events')) {
        try {
          const dynamoData = await dynamodb.query({
            TableName: 'UserAnalytics',
            KeyConditionExpression: 'userId = :userId',
            FilterExpression: '#timestamp BETWEEN :startDate AND :endDate',
            ExpressionAttributeNames: {
              '#timestamp': 'timestamp'
            },
            ExpressionAttributeValues: {
              ':userId': userId,
              ':startDate': startDate.getTime(),
              ':endDate': endDate.getTime()
            },
            ScanIndexForward: false,
            Limit: 10000
          }).promise()

          const events = dynamoData.Items || []
          const eventStats = events.reduce((acc, event) => {
            if (!acc[event.eventType]) acc[event.eventType] = 0
            acc[event.eventType]++
            return acc
          }, {})

          analyticsData.events = {
            total: events.length,
            byType: eventStats,
            raw: events.slice(0, 100) // Limit raw events
          }
        } catch (dynamoError) {
          logger.error('DynamoDB query error:', dynamoError)
          analyticsData.events = { error: 'Unable to fetch event data' }
        }
      }

      // Get payment/transaction data
      if (parsedMetrics.includes('all') || parsedMetrics.includes('payments')) {
        const transactions = await prisma.transaction.findMany({
          where: {
            userId,
            createdAt: {
              gte: startDate,
              lte: endDate
            }
          },
          orderBy: { createdAt: 'desc' }
        })

        const paymentStats = {
          totalTransactions: transactions.length,
          totalAmount: transactions.reduce((sum, t) => sum + t.amount, 0),
          successfulPayments: transactions.filter(t => t.status === 'completed').length,
          failedPayments: transactions.filter(t => t.status === 'failed').length,
          averageTransactionValue: transactions.length > 0 
            ? transactions.reduce((sum, t) => sum + t.amount, 0) / transactions.length
            : 0,
          monthlyRevenue: transactions
            .filter(t => t.status === 'completed')
            .reduce((acc, t) => {
              const month = moment(t.createdAt).format('YYYY-MM')
              acc[month] = (acc[month] || 0) + t.amount
              return acc
            }, {})
        }

        analyticsData.payments = paymentStats
      }

      // Generate insights using basic analytics
      const insights = []
      
      if (analyticsData.activities) {
        const recentActivities = Object.values(analyticsData.activities.grouped).slice(-7)
        const avgDailyActivity = recentActivities.reduce((sum, day) => 
          sum + Object.values(day).reduce((daySum, count) => daySum + count, 0), 0
        ) / recentActivities.length

        if (avgDailyActivity > 10) {
          insights.push({
            type: 'positive',
            title: 'High Activity',
            message: `You've been very active with an average of ${Math.round(avgDailyActivity)} actions per day.`
          })
        }
      }

      if (analyticsData.sessions) {
        if (analyticsData.sessions.total > 20) {
          insights.push({
            type: 'info',
            title: 'Frequent User',
            message: `You had ${analyticsData.sessions.total} login sessions in this period.`
          })
        }
      }

      analyticsData.insights = insights

      // Export functionality
      if (exportFormat) {
        let exportData = null
        let contentType = 'application/json'
        let filename = `analytics-${userId}-${dateRange}.json`

        switch (exportFormat) {
          case 'json':
            exportData = Buffer.from(JSON.stringify(analyticsData, null, 2))
            break

          case 'csv':
            // Convert activities to CSV
            if (analyticsData.activities) {
              const csvData = analyticsData.activities.raw.map(activity => ({
                date: moment(activity.timestamp).format('YYYY-MM-DD HH:mm:ss'),
                action: activity.action,
                details: JSON.stringify(activity.details),
                ipAddress: activity.ipAddress,
                location: activity.location
              }))

              const csvString = [
                Object.keys(csvData[0]).join(','),
                ...csvData.map(row => Object.values(row).map(val => 
                  typeof val === 'string' && val.includes(',') ? `"${val}"` : val
                ).join(','))
              ].join('\n')

              exportData = Buffer.from(csvString)
              contentType = 'text/csv'
              filename = `analytics-${userId}-${dateRange}.csv`
            }
            break

          case 'xlsx':
            // Create Excel file
            const workbook = new ExcelJS.Workbook()
            
            if (analyticsData.activities) {
              const worksheet = workbook.addWorksheet('Activities')
              worksheet.columns = [
                { header: 'Date', key: 'date', width: 20 },
                { header: 'Action', key: 'action', width: 20 },
                { header: 'Details', key: 'details', width: 40 },
                { header: 'IP Address', key: 'ipAddress', width: 15 },
                { header: 'Location', key: 'location', width: 20 }
              ]

              analyticsData.activities.raw.forEach(activity => {
                worksheet.addRow({
                  date: moment(activity.timestamp).format('YYYY-MM-DD HH:mm:ss'),
                  action: activity.action,
                  details: JSON.stringify(activity.details),
                  ipAddress: activity.ipAddress,
                  location: activity.location
                })
              })
            }

            exportData = await workbook.xlsx.writeBuffer()
            contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            filename = `analytics-${userId}-${dateRange}.xlsx`
            break

          case 'pdf':
            exportData = await generatePDF({
              'User ID': userId,
              'Date Range': dateRange,
              'Total Activities': analyticsData.activities?.total || 0,
              'Total Sessions': analyticsData.sessions?.total || 0,
              'Total Events': analyticsData.events?.total || 0,
              'Generated At': new Date().toISOString()
            })
            contentType = 'application/pdf'
            filename = `analytics-${userId}-${dateRange}.pdf`
            break
        }

        if (exportData) {
          // Store export in database for tracking
          await prisma.export.create({
            data: {
              userId,
              type: 'analytics',
              format: exportFormat,
              filename,
              size: exportData.length,
              parameters: JSON.stringify({ dateRange, metrics: parsedMetrics }),
              createdAt: new Date()
            }
          })

          res.setHeader('Content-Type', contentType)
          res.setHeader('Content-Disposition', `attachment; filename=${filename}`)
          return res.send(exportData)
        }
      }

      // Log analytics access
      await logActivity(userId, 'ANALYTICS_ACCESSED', {
        dateRange,
        metrics: parsedMetrics,
        exportFormat,
        accessedBy: req.user.id,
        ipAddress: req.ip
      })

      // Update analytics access counter
      await processAnalytics(userId, 'analytics_view', {
        dateRange,
        metricsRequested: parsedMetrics,
        exportRequested: !!exportFormat
      })

      res.json({
        success: true,
        data: analyticsData,
        meta: {
          dateRange: {
            start: startDate.toISOString(),
            end: endDate.toISOString()
          },
          metrics: parsedMetrics,
          generatedAt: new Date().toISOString()
        }
      })

    } catch (error) {
      logger.error('Analytics fetch error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Analytics fetch failed' })
    }
  }
)

// Complex Data Import with Multiple Formats
app.post('/api/users/import',
  uploadRateLimit,
  authenticateJWT,
  upload.single('file'),
  [
    body('importType').isIn(['contacts', 'transactions', 'activities', 'products', 'users']),
    body('mapping').optional().isJSON(),
    body('options').optional().isJSON()
  ],
  validateRequest,
  async (req, res) => {
    try {
      const { importType, mapping = '{}', options = '{}' } = req.body
      const userId = req.user.id
      
      if (!req.file) {
        return res.status(400).json({ error: 'File is required' })
      }

      const parsedMapping = JSON.parse(mapping)
      const parsedOptions = JSON.parse(options)
      const importId = uuidv4()

      // Store import job in database
      const importJob = await prisma.import.create({
        data: {
          id: importId,
          userId,
          type: importType,
          filename: req.file.originalname,
          fileSize: req.file.size,
          status: 'processing',
          mapping: parsedMapping,
          options: parsedOptions,
          createdAt: new Date()
        }
      })

      // Process file based on type
      let processedData = []
      const fileExtension = path.extname(req.file.originalname).toLowerCase()

      try {
        switch (fileExtension) {
          case '.csv':
            processedData = await processCSV(req.file.buffer)
            break
          case '.xlsx':
          case '.xls':
            processedData = await processExcel(req.file.buffer)
            break
          case '.json':
            processedData = JSON.parse(req.file.buffer.toString())
            break
          default:
            throw new Error('Unsupported file format')
        }

        // Validate and transform data based on import type
        const validatedData = []
        const errors = []

        for (let i = 0; i < processedData.length; i++) {
          const row = processedData[i]
          
          try {
            let transformedRow = {}

            switch (importType) {
              case 'contacts':
                transformedRow = {
                  firstName: row[parsedMapping.firstName || 'firstName'] || row.firstName,
                  lastName: row[parsedMapping.lastName || 'lastName'] || row.lastName,
                  email: row[parsedMapping.email || 'email'] || row.email,
                  phoneNumber: row[parsedMapping.phoneNumber || 'phoneNumber'] || row.phoneNumber,
                  company: row[parsedMapping.company || 'company'] || row.company,
                  notes: row[parsedMapping.notes || 'notes'] || row.notes,
                  tags: row[parsedMapping.tags || 'tags'] ? 
                    (typeof row[parsedMapping.tags] === 'string' ? 
                      row[parsedMapping.tags].split(',').map(t => t.trim()) : 
                      row[parsedMapping.tags]) : []
                }

                // Validate email
                if (transformedRow.email && !validator.isEmail(transformedRow.email)) {
                  errors.push({ row: i + 1, field: 'email', message: 'Invalid email format' })
                  continue
                }

                // Validate phone
                if (transformedRow.phoneNumber && !validator.isMobilePhone(transformedRow.phoneNumber)) {
                  errors.push({ row: i + 1, field: 'phoneNumber', message: 'Invalid phone format' })
                  continue
                }
                break

              case 'transactions':
                transformedRow = {
                  amount: parseFloat(row[parsedMapping.amount || 'amount'] || row.amount),
                  currency: row[parsedMapping.currency || 'currency'] || row.currency || 'USD',
                  description: row[parsedMapping.description || 'description'] || row.description,
                  category: row[parsedMapping.category || 'category'] || row.category,
                  date: new Date(row[parsedMapping.date || 'date'] || row.date),
                  reference: row[parsedMapping.reference || 'reference'] || row.reference,
                  status: row[parsedMapping.status || 'status'] || row.status || 'completed'
                }

                // Validate amount
                if (isNaN(transformedRow.amount)) {
                  errors.push({ row: i + 1, field: 'amount', message: 'Invalid amount' })
                  continue
                }

                // Validate date
                if (isNaN(transformedRow.date.getTime())) {
                  errors.push({ row: i + 1, field: 'date', message: 'Invalid date' })
                  continue
                }
                break

              case 'products':
                transformedRow = {
                  name: row[parsedMapping.name || 'name'] || row.name,
                  description: row[parsedMapping.description || 'description'] || row.description,
                  price: parseFloat(row[parsedMapping.price || 'price'] || row.price),
                  category: row[parsedMapping.category || 'category'] || row.category,
                  sku: row[parsedMapping.sku || 'sku'] || row.sku,
                  stock: parseInt(row[parsedMapping.stock || 'stock'] || row.stock) || 0,
                  status: row[parsedMapping.status || 'status'] || row.status || 'active'
                }

                // Validate required fields
                if (!transformedRow.name) {
                  errors.push({ row: i + 1, field: 'name', message: 'Name is required' })
                  continue
                }

                if (isNaN(transformedRow.price)) {
                  errors.push({ row: i + 1, field: 'price', message: 'Invalid price' })
                  continue
                }
                break

              default:
                transformedRow = row
            }

            validatedData.push(transformedRow)

          } catch (rowError) {
            errors.push({ row: i + 1, message: rowError.message })
          }
        }

        // Store processed data in database
        let importResults = {
          success: 0,
          failed: 0,
          skipped: 0
        }

        if (validatedData.length > 0 && errors.length < processedData.length * 0.5) {
          // Proceed with import if less than 50% errors
          
          for (const item of validatedData) {
            try {
              switch (importType) {
                case 'contacts':
                  // Check for duplicates
                  const existingContact = await prisma.contact.findFirst({
                    where: {
                      userId,
                      email: item.email
                    }
                  })

                  if (existingContact && !parsedOptions.allowDuplicates) {
                    importResults.skipped++
                    continue
                  }

                  await prisma.contact.create({
                    data: {
                      userId,
                      ...item,
                      importId
                    }
                  })
                  break

                case 'transactions':
                  await prisma.transaction.create({
                    data: {
                      userId,
                      ...item,
                      importId
                    }
                  })
                  break

                case 'products':
                  await prisma.product.create({
                    data: {
                      userId,
                      ...item,
                      importId
                    }
                  })
                  break
              }

              importResults.success++

            } catch (dbError) {
              logger.error('Import item error:', dbError)
              importResults.failed++
            }
          }
        }

        // Update import job status
        await prisma.import.update({
          where: { id: importId },
          data: {
            status: errors.length > 0 ? 'completed_with_errors' : 'completed',
            processedRows: processedData.length,
            successfulRows: importResults.success,
            failedRows: importResults.failed + errors.length,
            skippedRows: importResults.skipped,
            errors: JSON.stringify(errors),
            completedAt: new Date()
          }
        })

        // Send completion email
        const emailHtml = `
          <h2>Import Completed</h2>
          <p>Your ${importType} import has been completed.</p>
          <p><strong>File:</strong> ${req.file.originalname}</p>
          <p><strong>Total Rows:</strong> ${processedData.length}</p>
          <p><strong>Successful:</strong> ${importResults.success}</p>
          <p><strong>Failed:</strong> ${importResults.failed + errors.length}</p>
          <p><strong>Skipped:</strong> ${importResults.skipped}</p>
          ${errors.length > 0 ? `<p><strong>Errors:</strong> ${errors.length} validation errors found</p>` : ''}
          <p>You can view the detailed results in your dashboard.</p>
        `

        if (rabbitmqChannel) {
          await rabbitmqChannel.sendToQueue(
            'email_queue',
            Buffer.from(JSON.stringify({
              to: req.user.email,
              subject: `Import Completed - ${importType}`,
              html: emailHtml,
              priority: 'normal'
            })),
            { persistent: true }
          )
        }

        // Log import activity
        await logActivity(userId, 'DATA_IMPORTED', {
          importId,
          type: importType,
          filename: req.file.originalname,
          totalRows: processedData.length,
          successfulRows: importResults.success,
          failedRows: importResults.failed + errors.length,
          errors: errors.length,
          ipAddress: req.ip
        })

        // Process analytics
        await processAnalytics(userId, 'data_import', {
          type: importType,
          fileSize: req.file.size,
          rowsProcessed: processedData.length,
          successRate: (importResults.success / processedData.length) * 100
        })

        res.json({
          success: true,
          message: 'Import completed',
          importId,
          results: {
            totalRows: processedData.length,
            successful: importResults.success,
            failed: importResults.failed + errors.length,
            skipped: importResults.skipped,
            errors: errors.slice(0, 10), // Return first 10 errors
            hasMoreErrors: errors.length > 10
          }
        })

      } catch (processingError) {
        // Update import job as failed
        await prisma.import.update({
          where: { id: importId },
          data: {
            status: 'failed',
            errors: JSON.stringify([{ message: processingError.message }]),
            completedAt: new Date()
          }
        })

        throw processingError
      }

    } catch (error) {
      logger.error('Import error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Import failed', details: error.message })
    }
  }
)

// Complex Real-time Notification System
app.post('/api/notifications/send',
  strictRateLimit,
  authenticateJWT,
  [
    body('recipients').isArray().notEmpty(),
    body('type').isIn(['email', 'push', 'sms', 'in_app', 'webhook']),
    body('title').trim().isLength({ min: 1, max: 200 }),
    body('message').trim().isLength({ min: 1, max: 1000 }),
    body('priority').optional().isIn(['low', 'normal', 'high', 'urgent']),
    body('scheduledFor').optional().isISO8601(),
    body('data').optional().isJSON()
  ],
  validateRequest,
  async (req, res) => {
    try {
      const {
        recipients,
        type,
        title,
        message,
        priority = 'normal',
        scheduledFor = null,
        data = '{}',
        templateId = null,
        personalization = '{}'
      } = req.body

      const senderId = req.user.id
      const parsedData = JSON.parse(data)
      const parsedPersonalization = JSON.parse(personalization)
      const notificationId = uuidv4()

      // Check sender permissions
      if (type === 'sms' && !req.user.permissions?.notifications?.sms) {
        return res.status(403).json({ error: 'SMS permissions required' })
      }

      if (recipients.length > 1000 && !req.user.permissions?.notifications?.bulk) {
        return res.status(403).json({ error: 'Bulk notification permissions required' })
      }

      // Validate recipients
      const validRecipients = []
      for (const recipient of recipients) {
        if (typeof recipient === 'string') {
          // Email or phone
          if (validator.isEmail(recipient)) {
            validRecipients.push({ type: 'email', value: recipient })
          } else if (validator.isMobilePhone(recipient)) {
            validRecipients.push({ type: 'phone', value: recipient })
          }
        } else if (typeof recipient === 'object' && recipient.userId) {
          // User ID
          const user = await userLoader.load(recipient.userId)
          if (user) {
            validRecipients.push({ 
              type: 'user', 
              userId: user.id,
              email: user.email,
              phoneNumber: user.phoneNumber,
              preferences: user.preferences
            })
          }
        }
      }

      if (validRecipients.length === 0) {
        return res.status(400).json({ error: 'No valid recipients found' })
      }

      // Create notification record
      const notification = await prisma.notification.create({
        data: {
          id: notificationId,
          senderId,
          type,
          title,
          message,
          priority,
          scheduledFor: scheduledFor ? new Date(scheduledFor) : null,
          data: parsedData,
          templateId,
          status: scheduledFor ? 'scheduled' : 'sending',
          recipientCount: validRecipients.length,
          createdAt: new Date()
        }
      })

      // Process notifications
      const results = {
        sent: 0,
        failed: 0,
        scheduled: 0,
        errors: []
      }

      for (const recipient of validRecipients) {
        try {
          let personalizedTitle = title
          let personalizedMessage = message

          // Apply personalization
          if (recipient.type === 'user' && Object.keys(parsedPersonalization).length > 0) {
            const user = await userLoader.load(recipient.userId)
            personalizedTitle = title.replace(/\{\{(\w+)\}\}/g, (match, key) => 
              user[key] || parsedPersonalization[key] || match
            )
            personalizedMessage = message.replace(/\{\{(\w+)\}\}/g, (match, key) => 
              user[key] || parsedPersonalization[key] || match
            )
          }

          // Create recipient record
          const recipientRecord = await prisma.notificationRecipient.create({
            data: {
              notificationId,
              recipientType: recipient.type,
              recipientId: recipient.userId || null,
              email: recipient.email || recipient.value,
              phoneNumber: recipient.phoneNumber || (recipient.type === 'phone' ? recipient.value : null),
              status: scheduledFor ? 'scheduled' : 'pending'
            }
          })

          if (scheduledFor) {
            // Schedule for later
            results.scheduled++
            continue
          }

          // Send immediately based on type
          switch (type) {
            case 'email':
              const emailRecipient = recipient.email || recipient.value
              await sendEmail(emailRecipient, personalizedTitle, personalizedMessage)
              
              await prisma.notificationRecipient.update({
                where: { id: recipientRecord.id },
                data: { status: 'sent', sentAt: new Date() }
              })
              results.sent++
              break

            case 'push':
              if (recipient.type === 'user') {
                const pushSubscriptions = await prisma.pushSubscription.findMany({
                  where: { userId: recipient.userId, active: true }
                })

                for (const subscription of pushSubscriptions) {
                  await sendPushNotification(JSON.parse(subscription.subscription), {
                    title: personalizedTitle,
                    body: personalizedMessage,
                    icon: '/icon-192x192.png',
                    data: parsedData
                  })
                }

                await prisma.notificationRecipient.update({
                  where: { id: recipientRecord.id },
                  data: { status: 'sent', sentAt: new Date() }
                })
                results.sent++
              }
              break

            case 'sms':
              const phoneRecipient = recipient.phoneNumber || recipient.value
              await twilio.messages.create({
                body: `${personalizedTitle}\n\n${personalizedMessage}`,
                from: process.env.TWILIO_PHONE_NUMBER,
                to: phoneRecipient
              })

              await prisma.notificationRecipient.update({
                where: { id: recipientRecord.id },
                data: { status: 'sent', sentAt: new Date() }
              })
              results.sent++
              break

            case 'in_app':
              if (recipient.type === 'user') {
                await prisma.userNotification.create({
                  data: {
                    userId: recipient.userId,
                    title: personalizedTitle,
                    message: personalizedMessage,
                    type: 'info',
                    priority,
                    data: parsedData,
                    read: false
                  }
                })

                // Send via WebSocket if connected
                const io = req.app.get('io')
                if (io) {
                  io.to(`user:${recipient.userId}`).emit('notification', {
                    id: notificationId,
                    title: personalizedTitle,
                    message: personalizedMessage,
                    type: 'info',
                    priority,
                    data: parsedData,
                    timestamp: new Date().toISOString()
                  })
                }

                await prisma.notificationRecipient.update({
                  where: { id: recipientRecord.id },
                  data: { status: 'sent', sentAt: new Date() }
                })
                results.sent++
              }
              break

            case 'webhook':
              if (recipient.webhookUrl) {
                const webhookPayload = {
                  id: notificationId,
                  title: personalizedTitle,
                  message: personalizedMessage,
                  priority,
                  data: parsedData,
                  timestamp: new Date().toISOString(),
                  recipient: recipient.userId || recipient.value
                }

                await axios.post(recipient.webhookUrl, webhookPayload, {
                  timeout: 10000,
                  headers: {
                    'Content-Type': 'application/json',
                    'X-Notification-ID': notificationId,
                    'X-Sender-ID': senderId
                  }
                })

                await prisma.notificationRecipient.update({
                  where: { id: recipientRecord.id },
                  data: { status: 'sent', sentAt: new Date() }
                })
                results.sent++
              }
              break
          }

        } catch (recipientError) {
          logger.error('Notification send error:', recipientError)
          results.failed++
          results.errors.push({
            recipient: recipient.email || recipient.userId || recipient.value,
            error: recipientError.message
          })

          // Update recipient status
          await prisma.notificationRecipient.update({
            where: { id: recipientRecord.id },
            data: { 
              status: 'failed', 
              error: recipientError.message,
              failedAt: new Date()
            }
          })
        }
      }

      // Update notification status
      const finalStatus = results.failed > 0 
        ? (results.sent > 0 ? 'partially_sent' : 'failed')
        : (results.scheduled > 0 ? 'scheduled' : 'sent')

      await prisma.notification.update({
        where: { id: notificationId },
        data: {
          status: finalStatus,
          sentCount: results.sent,
          failedCount: results.failed,
          scheduledCount: results.scheduled,
          completedAt: new Date()
        }
      })

      // Log activity
      await logActivity(senderId, 'NOTIFICATION_SENT', {
        notificationId,
        type,
        recipientCount: validRecipients.length,
        sent: results.sent,
        failed: results.failed,
        scheduled: results.scheduled,
        ipAddress: req.ip
      })

      // Process analytics
      await processAnalytics(senderId, 'notification_sent', {
        type,
        recipientCount: validRecipients.length,
        priority,
        successRate: (results.sent / validRecipients.length) * 100
      })

      res.json({
        success: true,
        message: 'Notification processing completed',
        notificationId,
        results: {
          sent: results.sent,
          failed: results.failed,
          scheduled: results.scheduled,
          errors: results.errors.slice(0, 10) // Return first 10 errors
        }
      })

    } catch (error) {
      logger.error('Notification error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Notification failed' })
    }
  }
)

// Complex Payment Processing with Subscriptions and Webhooks
app.post('/api/payments/process',
  strictRateLimit,
  authenticateJWT,
  [
    body('amount').isFloat({ min: 0.01 }),
    body('currency').isIn(['USD', 'EUR', 'GBP', 'CAD', 'AUD']),
    body('paymentMethodId').notEmpty(),
    body('description').trim().isLength({ min: 1, max: 500 }),
    body('metadata').optional().isJSON(),
    body('subscriptionPlan').optional().isIn(['basic', 'pro', 'enterprise']),
    body('billingCycle').optional().isIn(['monthly', 'yearly'])
  ],
  validateRequest,
  async (req, res) => {
    try {
      const {
        amount,
        currency,
        paymentMethodId,
        description,
        metadata = '{}',
        subscriptionPlan = null,
        billingCycle = 'monthly',
        couponCode = null
      } = req.body

      const userId = req.user.id
      const parsedMetadata = JSON.parse(metadata)
      
      // Get user's Stripe customer ID
      let stripeCustomerId = req.user.stripeCustomerId
      
      if (!stripeCustomerId) {
        // Create Stripe customer
        const stripeCustomer = await stripe.customers.create({
          email: req.user.email,
          name: `${req.user.firstName} ${req.user.lastName}`,
          metadata: { userId }
        })
        
        stripeCustomerId = stripeCustomer.id
        
        await prisma.user.update({
          where: { id: userId },
          data: { stripeCustomerId }
        })
      }

      let finalAmount = amount
      let appliedCoupon = null

      // Apply coupon if provided
      if (couponCode) {
        try {
          const coupon = await stripe.coupons.retrieve(couponCode)
          if (coupon.valid) {
            if (coupon.amount_off) {
              finalAmount = Math.max(0.01, amount - (coupon.amount_off / 100))
            } else if (coupon.percent_off) {
              finalAmount = amount * (1 - coupon.percent_off / 100)
            }
            appliedCoupon = coupon
          }
        } catch (couponError) {
          logger.warn('Invalid coupon code:', couponError)
        }
      }

      // Create payment intent
      const paymentIntentData = {
        amount: Math.round(finalAmount * 100), // Convert to cents
        currency,
        customer: stripeCustomerId,
        payment_method: paymentMethodId,
        description,
        metadata: {
          userId,
          ...parsedMetadata
        },
        confirm: true,
        automatic_payment_methods: { enabled: true, allow_redirects: 'never' }
      }

      if (appliedCoupon) {
        paymentIntentData.metadata.couponCode = couponCode
        paymentIntentData.metadata.discount = (amount - finalAmount).toString()
      }

      const paymentIntent = await stripe.paymentIntents.create(paymentIntentData)

      // Create transaction record
      const transaction = await prisma.transaction.create({
        data: {
          userId,
          stripePaymentIntentId: paymentIntent.id,
          amount: finalAmount,
          currency,
          description,
          status: paymentIntent.status === 'succeeded' ? 'completed' : 'pending',
          paymentMethod: 'stripe',
          metadata: {
            ...parsedMetadata,
            couponCode,
            originalAmount: amount,
            discount: appliedCoupon ? amount - finalAmount : 0
          },
          createdAt: new Date()
        }
      })

      // Handle subscription creation
      let subscription = null
      if (subscriptionPlan && paymentIntent.status === 'succeeded') {
        try {
          // Get subscription configuration
          const subscriptionConfig = {
            basic: {
              price: billingCycle === 'yearly' ? 99.99 : 9.99,
              features: {
                maxStorage: '10GB',
                maxApiCalls: 10000,
                supportLevel: 'standard',
                customBranding: false
              }
            },
            pro: {
              price: billingCycle === 'yearly' ? 299.99 : 29.99,
              features: {
                maxStorage: '100GB',
                maxApiCalls: 100000,
                supportLevel: 'priority',
                customBranding: true,
                advancedAnalytics: true
              }
            },
            enterprise: {
              price: billingCycle === 'yearly' ? 999.99 : 99.99,
              features: {
                maxStorage: '1TB',
                maxApiCalls: 1000000,
                supportLevel: 'dedicated',
                customBranding: true,
                advancedAnalytics: true,
                apiAccess: true,
                whiteLabel: true
              }
            }
          }

          const config = subscriptionConfig[subscriptionPlan]
          if (config) {
            // Cancel existing subscription
            const existingSubscription = await prisma.subscription.findFirst({
              where: { userId, status: 'active' }
            })

            if (existingSubscription) {
              await prisma.subscription.update({
                where: { id: existingSubscription.id },
                data: { 
                  status: 'cancelled',
                  cancelledAt: new Date(),
                  cancelReason: 'upgraded'
                }
              })
            }

            // Create new subscription
            const endDate = new Date()
            if (billingCycle === 'yearly') {
              endDate.setFullYear(endDate.getFullYear() + 1)
            } else {
              endDate.setMonth(endDate.getMonth() + 1)
            }

            subscription = await prisma.subscription.create({
              data: {
                userId,
                plan: subscriptionPlan,
                status: 'active',
                billingCycle,
                amount: config.price,
                currency,
                startDate: new Date(),
                endDate,
                features: JSON.stringify(config.features),
                transactionId: transaction.id
              }
            })

            // Update user permissions based on plan
            await prisma.user.update({
              where: { id: userId },
              data: {
                subscriptionPlan,
                subscriptionStatus: 'active'
              }
            })

            // Send welcome email for new subscription
            const welcomeHtml = `
              <h1>Welcome to ${subscriptionPlan.charAt(0).toUpperCase() + subscriptionPlan.slice(1)}!</h1>
              <p>Your subscription has been activated successfully.</p>
              <h3>Your Plan Includes:</h3>
              <ul>
                ${Object.entries(config.features).map(([key, value]) => 
                  `<li><strong>${key}:</strong> ${value}</li>`
                ).join('')}
              </ul>
              <p><strong>Billing Cycle:</strong> ${billingCycle}</p>
              <p><strong>Next Billing Date:</strong> ${endDate.toLocaleDateString()}</p>
              <p>Thank you for choosing our service!</p>
            `

            if (rabbitmqChannel) {
              await rabbitmqChannel.sendToQueue(
                'email_queue',
                Buffer.from(JSON.stringify({
                  to: req.user.email,
                  subject: `Welcome to ${subscriptionPlan} Plan!`,
                  html: welcomeHtml,
                  priority: 'high'
                })),
                { persistent: true }
              )
            }
          }
        } catch (subscriptionError) {
          logger.error('Subscription creation error:', subscriptionError)
        }
      }

      // Send payment confirmation
      if (paymentIntent.status === 'succeeded') {
        const confirmationHtml = `
          <h1>Payment Confirmation</h1>
          <p>Your payment has been processed successfully.</p>
          <p><strong>Amount:</strong> ${currency} ${finalAmount.toFixed(2)}</p>
          <p><strong>Description:</strong> ${description}</p>
          <p><strong>Transaction ID:</strong> ${transaction.id}</p>
          <p><strong>Date:</strong> ${new Date().toLocaleDateString()}</p>
          ${appliedCoupon ? `<p><strong>Discount Applied:</strong> ${couponCode} - ${currency} ${(amount - finalAmount).toFixed(2)}</p>` : ''}
          <p>Thank you for your payment!</p>
        `

        if (rabbitmqChannel) {
          await rabbitmqChannel.sendToQueue(
            'email_queue',
            Buffer.from(JSON.stringify({
              to: req.user.email,
              subject: 'Payment Confirmation',
              html: confirmationHtml,
              priority: 'high'
            })),
            { persistent: true }
          )
        }

        // Send SMS confirmation if enabled
        if (req.user.phoneNumber && req.user.preferences?.notifications?.sms) {
          try {
            await twilio.messages.create({
              body: `Payment confirmed: ${currency} ${finalAmount.toFixed(2)} for ${description}. Transaction ID: ${transaction.id}`,
              from: process.env.TWILIO_PHONE_NUMBER,
              to: req.user.phoneNumber
            })
          } catch (smsError) {
            logger.error('SMS confirmation error:', smsError)
          }
        }

        // Process payment analytics
        await processAnalytics(userId, 'payment_successful', {
          amount: finalAmount,
          currency,
          subscriptionPlan,
          billingCycle,
          couponUsed: !!appliedCoupon,
          discount: appliedCoupon ? amount - finalAmount : 0
        })

        // Update user analytics
        await prisma.userAnalytics.update({
          where: { userId },
          data: {
            totalSpent: { increment: finalAmount },
            totalTransactions: { increment: 1 },
            lastPurchaseDate: new Date()
          }
        })
      }

      // Log payment activity
      await logActivity(userId, 'PAYMENT_PROCESSED', {
        transactionId: transaction.id,
        amount: finalAmount,
        currency,
        status: paymentIntent.status,
        subscriptionPlan,
        couponCode,
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      })

      res.json({
        success: paymentIntent.status === 'succeeded',
        message: paymentIntent.status === 'succeeded' ? 'Payment successful' : 'Payment requires additional action',
        paymentIntent: {
          id: paymentIntent.id,
          status: paymentIntent.status,
          amount: finalAmount,
          currency,
          clientSecret: paymentIntent.client_secret
        },
        transaction: {
          id: transaction.id,
          status: transaction.status
        },
        subscription: subscription ? {
          id: subscription.id,
          plan: subscription.plan,
          status: subscription.status,
          endDate: subscription.endDate
        } : null,
        appliedDiscount: appliedCoupon ? {
          code: couponCode,
          amount: amount - finalAmount
        } : null
      })

    } catch (error) {
      logger.error('Payment processing error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Payment processing failed', details: error.message })
    }
  }
)

// Complex Webhook Handler for Multiple Services
app.post('/api/webhooks/:service',
  express.raw({ type: 'application/json' }),
  async (req, res) => {
    try {
      const { service } = req.params
      const signature = req.headers['stripe-signature'] || req.headers['x-hub-signature-256']
      
      let event
      let isValid = false

      switch (service) {
        case 'stripe':
          try {
            event = stripe.webhooks.constructEvent(req.body, signature, process.env.STRIPE_WEBHOOK_SECRET)
            isValid = true
          } catch (err) {
            logger.error('Stripe webhook signature verification failed:', err)
            return res.status(400).send(`Webhook signature verification failed: ${err.message}`)
          }
          break

        case 'github':
          // Verify GitHub webhook signature
          const githubSignature = req.headers['x-hub-signature-256']
          const githubSecret = process.env.GITHUB_WEBHOOK_SECRET
          
          if (githubSignature && githubSecret) {
            const expectedSignature = 'sha256=' + crypto
              .createHmac('sha256', githubSecret)
              .update(req.body)
              .digest('hex')
            
            isValid = crypto.timingSafeEqual(
              Buffer.from(githubSignature),
              Buffer.from(expectedSignature)
            )
          }
          
          if (isValid) {
            event = JSON.parse(req.body)
            event.type = req.headers['x-github-event']
          }
          break

        case 'twilio':
          // Verify Twilio webhook signature
          const twilioSignature = req.headers['x-twilio-signature']
          const twilioAuthToken = process.env.TWILIO_AUTH_TOKEN
          const url = `${req.protocol}://${req.get('host')}${req.originalUrl}`
          
          const twilioSignatureValid = twilio.validateRequest(
            twilioAuthToken,
            twilioSignature,
            url,
            req.body
          )
          
          if (twilioSignatureValid) {
            event = req.body
            event.type = 'sms_status'
            isValid = true
          }
          break

        default:
          return res.status(400).json({ error: 'Unknown webhook service' })
      }

      if (!isValid) {
        return res.status(401).json({ error: 'Webhook signature verification failed' })
      }

      // Process webhook based on service and event type
      switch (service) {
        case 'stripe':
          await handleStripeWebhook(event)
          break
        case 'github':
          await handleGitHubWebhook(event)
          break
        case 'twilio':
          await handleTwilioWebhook(event)
          break
      }

      // Log webhook receipt
      await logActivity(null, 'WEBHOOK_RECEIVED', {
        service,
        eventType: event.type,
        eventId: event.id || event.delivery_id || 'unknown',
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      })

      res.json({ success: true, message: 'Webhook processed successfully' })

    } catch (error) {
      logger.error('Webhook processing error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Webhook processing failed' })
    }
  }
)

// Webhook handlers
const handleStripeWebhook = async (event) => {
  switch (event.type) {
    case 'payment_intent.succeeded':
      const paymentIntent = event.data.object
      const userId = paymentIntent.metadata.userId
      
      // Update transaction status
      await prisma.transaction.updateMany({
        where: { stripePaymentIntentId: paymentIntent.id },
        data: { 
          status: 'completed',
          completedAt: new Date()
        }
      })

      // Process successful payment analytics
      if (userId) {
        await processAnalytics(userId, 'payment_confirmed', {
          amount: paymentIntent.amount / 100,
          currency: paymentIntent.currency
        })
      }
      break

    case 'payment_intent.payment_failed':
      const failedPayment = event.data.object
      const failedUserId = failedPayment.metadata.userId
      
      // Update transaction status
      await prisma.transaction.updateMany({
        where: { stripePaymentIntentId: failedPayment.id },
        data: { 
          status: 'failed',
          failedAt: new Date(),
          failureReason: failedPayment.last_payment_error?.message
        }
      })

      // Send payment failure notification
      if (failedUserId) {
        const user = await userLoader.load(failedUserId)
        if (user) {
          const failureHtml = `
            <h1>Payment Failed</h1>
            <p>We were unable to process your payment.</p>
            <p><strong>Amount:</strong> ${failedPayment.currency.toUpperCase()} ${(failedPayment.amount / 100).toFixed(2)}</p>
            <p><strong>Reason:</strong> ${failedPayment.last_payment_error?.message || 'Unknown error'}</p>
            <p>Please try again or contact support if the problem persists.</p>
          `

          if (rabbitmqChannel) {
            await rabbitmqChannel.sendToQueue(
              'email_queue',
              Buffer.from(JSON.stringify({
                to: user.email,
                subject: 'Payment Failed',
                html: failureHtml,
                priority: 'high'
              })),
              { persistent: true }
            )
          }
        }

        await processAnalytics(failedUserId, 'payment_failed', {
          amount: failedPayment.amount / 100,
          currency: failedPayment.currency,
          reason: failedPayment.last_payment_error?.message
        })
      }
      break

    case 'customer.subscription.created':
    case 'customer.subscription.updated':
      const subscription = event.data.object
      const customerId = subscription.customer
      
      // Find user by Stripe customer ID
      const user = await prisma.user.findFirst({
        where: { stripeCustomerId: customerId }
      })
      
      if (user) {
        const subscriptionStatus = subscription.status === 'active' ? 'active' : 
                                 subscription.status === 'canceled' ? 'cancelled' : 
                                 subscription.status

        await prisma.subscription.upsert({
          where: { stripeSubscriptionId: subscription.id },
          update: {
            status: subscriptionStatus,
            currentPeriodStart: new Date(subscription.current_period_start * 1000),
            currentPeriodEnd: new Date(subscription.current_period_end * 1000)
          },
          create: {
            userId: user.id,
            stripeSubscriptionId: subscription.id,
            plan: subscription.items.data[0]?.price?.nickname || 'unknown',
            status: subscriptionStatus,
            amount: subscription.items.data[0]?.price?.unit_amount / 100,
            currency: subscription.currency,
            startDate: new Date(subscription.start_date * 1000),
            currentPeriodStart: new Date(subscription.current_period_start * 1000),
            currentPeriodEnd: new Date(subscription.current_period_end * 1000)
          }
        })

        await processAnalytics(user.id, 'subscription_updated', {
          status: subscriptionStatus,
          plan: subscription.items.data[0]?.price?.nickname
        })
      }
      break

    case 'invoice.payment_succeeded':
      const invoice = event.data.object
      const invoiceCustomerId = invoice.customer
      
      const invoiceUser = await prisma.user.findFirst({
        where: { stripeCustomerId: invoiceCustomerId }
      })
      
      if (invoiceUser) {
        await processAnalytics(invoiceUser.id, 'invoice_paid', {
          amount: invoice.amount_paid / 100,
          currency: invoice.currency
        })
      }
      break
  }
}

const handleGitHubWebhook = async (event) => {
  switch (event.type) {
    case 'push':
      // Handle code push events
      const repository = event.repository
      const pusher = event.pusher
      
      // Find user by GitHub username
      const user = await prisma.user.findFirst({
        where: {
          socialAccounts: {
            some: {
              provider: 'github',
              providerUserId: pusher.name
            }
          }
        }
      })

      if (user) {
        await logActivity(user.id, 'CODE_PUSHED', {
          repository: repository.full_name,
          commits: event.commits?.length || 0,
          ref: event.ref,
          pusher: pusher.name
        })

        await processAnalytics(user.id, 'github_push', {
          repository: repository.name,
          commits: event.commits?.length || 0,
          language: repository.language
        })
      }
      break

    case 'issues':
      if (event.action === 'opened') {
        // Handle new issue creation
        const issueUser = await prisma.user.findFirst({
          where: {
            socialAccounts: {
              some: {
                provider: 'github',
                providerUserId: event.issue.user.login
              }
            }
          }
        })

        if (issueUser) {
          await processAnalytics(issueUser.id, 'github_issue_created', {
            repository: event.repository.name,
            issueTitle: event.issue.title
          })
        }
      }
      break
  }
}

const handleTwilioWebhook = async (event) => {
  const messageStatus = event.MessageStatus || event.SmsStatus
  const messageSid = event.MessageSid || event.SmsSid
  
  if (messageStatus && messageSid) {
    // Update SMS delivery status
    await prisma.smsLog.updateMany({
      where: { twilioMessageSid: messageSid },
      data: { 
        status: messageStatus,
        updatedAt: new Date()
      }
    })

    // If delivery failed, log for analytics
    if (messageStatus === 'failed' || messageStatus === 'undelivered') {
      const smsLog = await prisma.smsLog.findFirst({
        where: { twilioMessageSid: messageSid }
      })
      
      if (smsLog) {
        await processAnalytics(smsLog.userId, 'sms_delivery_failed', {
          reason: event.ErrorMessage || 'Unknown error'
        })
      }
    }
  }
}

// Complex Search API with Multiple Filters and Facets
app.get('/api/search',
  strictRateLimit,
  authenticateJWT,
  [
    body('query').optional().trim().isLength({ max: 200 }),
    body('type').optional().isIn(['users', 'content', 'products', 'transactions', 'all']),
    body('filters').optional().isJSON(),
    body('sort').optional().isIn(['relevance', 'date', 'name', 'popularity']),
    body('page').optional().isInt({ min: 1 }),
    body('limit').optional().isInt({ min: 1, max: 100 })
  ],
  validateRequest,
  async (req, res) => {
    try {
      const {
        query = '',
        type = 'all',
        filters = '{}',
        sort = 'relevance',
        page = 1,
        limit = 20,
        facets = false
      } = req.query

      const parsedFilters = JSON.parse(filters)
      const offset = (parseInt(page) - 1) * parseInt(limit)
      const userId = req.user.id

      const searchResults = {
        query,
        results: [],
        facets: {},
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total: 0,
          totalPages: 0
        },
        executionTime: Date.now()
      }

      // Build search conditions
      const searchConditions = []
      
      if (query) {
        const searchTerms = query.split(' ').filter(term => term.length > 0)
        searchConditions.push(...searchTerms)
      }

      // Search users
      if (type === 'all' || type === 'users') {
        const userSearchWhere = {
          AND: [
            {
              OR: searchConditions.length > 0 ? [
                { firstName: { contains: query, mode: 'insensitive' } },
                { lastName: { contains: query, mode: 'insensitive' } },
                { email: { contains: query, mode: 'insensitive' } },
                { profile: { bio: { contains: query, mode: 'insensitive' } } }
              ] : [{}]
            },
            { isActive: true },
            { emailVerified: true }
          ]
        }

        // Apply filters
        if (parsedFilters.location) {
          userSearchWhere.AND.push({
            profile: { location: { contains: parsedFilters.location, mode: 'insensitive' } }
          })
        }

        if (parsedFilters.skills) {
          userSearchWhere.AND.push({
            profile: { skills: { hasSome: parsedFilters.skills } }
          })
        }

        if (parsedFilters.dateRange) {
          const startDate = new Date(parsedFilters.dateRange.start)
          const endDate = new Date(parsedFilters.dateRange.end)
          userSearchWhere.AND.push({
            createdAt: { gte: startDate, lte: endDate }
          })
        }

        const users = await prisma.user.findMany({
          where: userSearchWhere,
          include: {
            profile: true,
            analytics: true
          },
          orderBy: sort === 'name' ? { firstName: 'asc' } : 
                   sort === 'date' ? { createdAt: 'desc' } :
                   sort === 'popularity' ? { analytics: { totalLogins: 'desc' } } :
                   [{ firstName: 'asc' }], // Default relevance
          skip: type === 'users' ? offset : 0,
          take: type === 'users' ? parseInt(limit) : Math.min(5, parseInt(limit))
        })

        const userResults = users.map(user => ({
          id: user.id,
          type: 'user',
          title: `${user.firstName} ${user.lastName}`,
          description: user.profile?.bio || '',
          avatarUrl: user.avatarUrl,
          location: user.profile?.location,
          skills: user.profile?.skills || [],
          createdAt: user.createdAt,
          relevanceScore: calculateUserRelevance(user, query)
        }))

        searchResults.results.push(...userResults)

        // Count total users for pagination
        if (type === 'users') {
          const totalUsers = await prisma.user.count({ where: userSearchWhere })
          searchResults.pagination.total = totalUsers
          searchResults.pagination.totalPages = Math.ceil(totalUsers / parseInt(limit))
        }
      }

      // Search content/posts
      if (type === 'all' || type === 'content') {
        const contentSearchWhere = {
          AND: [
            {
              OR: searchConditions.length > 0 ? [
                { title: { contains: query, mode: 'insensitive' } },
                { content: { contains: query, mode: 'insensitive' } },
                { tags: { hasSome: searchConditions } }
              ] : [{}]
            },
            { published: true },
            { 
              OR: [
                { visibility: 'public' },
                { authorId: userId },
                { 
                  author: {
                    connections: {
                      some: {
                        OR: [
                          { userId: userId, status: 'accepted' },
                          { connectedUserId: userId, status: 'accepted' }
                        ]
                      }
                    }
                  }
                }
              ]
            }
          ]
        }

        // Apply content filters
        if (parsedFilters.category) {
          contentSearchWhere.AND.push({
            category: { equals: parsedFilters.category }
          })
        }

        if (parsedFilters.tags) {
          contentSearchWhere.AND.push({
            tags: { hasSome: parsedFilters.tags }
          })
        }

        const posts = await prisma.post.findMany({
          where: contentSearchWhere,
          include: {
            author: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                avatarUrl: true
              }
            },
            _count: {
              select: {
                likes: true,
                comments: true,
                shares: true
              }
            }
          },
          orderBy: sort === 'date' ? { createdAt: 'desc' } :
                   sort === 'popularity' ? { views: 'desc' } :
                   [{ createdAt: 'desc' }],
          skip: type === 'content' ? offset : 0,
          take: type === 'content' ? parseInt(limit) : Math.min(5, parseInt(limit))
        })

        const contentResults = posts.map(post => ({
          id: post.id,
          type: 'content',
          title: post.title,
          description: post.content?.substring(0, 200) + '...',
          author: post.author,
          category: post.category,
          tags: post.tags,
          stats: post._count,
          createdAt: post.createdAt,
          relevanceScore: calculateContentRelevance(post, query)
        }))

        searchResults.results.push(...contentResults)

        if (type === 'content') {
          const totalPosts = await prisma.post.count({ where: contentSearchWhere })
          searchResults.pagination.total = totalPosts
          searchResults.pagination.totalPages = Math.ceil(totalPosts / parseInt(limit))
        }
      }

      // Search products
      if (type === 'all' || type === 'products') {
        const productSearchWhere = {
          AND: [
            {
              OR: searchConditions.length > 0 ? [
                { name: { contains: query, mode: 'insensitive' } },
                { description: { contains: query, mode: 'insensitive' } },
                { category: { contains: query, mode: 'insensitive' } },
                { tags: { hasSome: searchConditions } }
              ] : [{}]
            },
            { status: 'active' }
          ]
        }

        // Apply product filters
        if (parsedFilters.priceRange) {
          productSearchWhere.AND.push({
            price: {
              gte: parsedFilters.priceRange.min,
              lte: parsedFilters.priceRange.max
            }
          })
        }

        if (parsedFilters.category) {
          productSearchWhere.AND.push({
            category: { equals: parsedFilters.category }
          })
        }

        const products = await prisma.product.findMany({
          where: productSearchWhere,
          include: {
            _count: {
              select: {
                reviews: true,
                orders: true
              }
            }
          },
          orderBy: sort === 'name' ? { name: 'asc' } :
                   sort === 'date' ? { createdAt: 'desc' } :
                   sort === 'popularity' ? { views: 'desc' } :
                   [{ name: 'asc' }],
          skip: type === 'products' ? offset : 0,
          take: type === 'products' ? parseInt(limit) : Math.min(5, parseInt(limit))
        })

        const productResults = products.map(product => ({
          id: product.id,
          type: 'product',
          title: product.name,
          description: product.description,
          price: product.price,
          currency: product.currency,
          category: product.category,
          imageUrl: product.imageUrl,
          stats: product._count,
          createdAt: product.createdAt,
          relevanceScore: calculateProductRelevance(product, query)
        }))

        searchResults.results.push(...productResults)

        if (type === 'products') {
          const totalProducts = await prisma.product.count({ where: productSearchWhere })
          searchResults.pagination.total = totalProducts
          searchResults.pagination.totalPages = Math.ceil(totalProducts / parseInt(limit))
        }
      }

      // Generate facets if requested
      if (facets && searchResults.results.length > 0) {
        // Category facets
        const categoryFacets = {}
        searchResults.results.forEach(result => {
          const category = result.category || result.type
          categoryFacets[category] = (categoryFacets[category] || 0) + 1
        })
        searchResults.facets.categories = categoryFacets

        // Date facets (last 7 days, last month, etc.)
        const now = new Date()
        const dateFacets = {
          'last_7_days': 0,
          'last_30_days': 0,
          'last_90_days': 0,
          'older': 0
        }

        searchResults.results.forEach(result => {
          const createdAt = new Date(result.createdAt)
          const daysDiff = Math.floor((now - createdAt) / (1000 * 60 * 60 * 24))
          
          if (daysDiff <= 7) dateFacets.last_7_days++
          else if (daysDiff <= 30) dateFacets.last_30_days++
          else if (daysDiff <= 90) dateFacets.last_90_days++
          else dateFacets.older++
        })
        searchResults.facets.dates = dateFacets

        // Type facets
        const typeFacets = {}
        searchResults.results.forEach(result => {
          typeFacets[result.type] = (typeFacets[result.type] || 0) + 1
        })
        searchResults.facets.types = typeFacets
      }

      // Sort results by relevance if needed
      if (sort === 'relevance' && query) {
        searchResults.results.sort((a, b) => (b.relevanceScore || 0) - (a.relevanceScore || 0))
      }

      // Calculate execution time
      searchResults.executionTime = Date.now() - searchResults.executionTime

      // Log search activity
      await logActivity(userId, 'SEARCH_PERFORMED', {
        query,
        type,
        filters: parsedFilters,
        resultsCount: searchResults.results.length,
        executionTime: searchResults.executionTime,
        ipAddress: req.ip
      })

      // Process search analytics
      await processAnalytics(userId, 'search', {
        query,
        type,
        resultsCount: searchResults.results.length,
        hasFilters: Object.keys(parsedFilters).length > 0,
        executionTime: searchResults.executionTime
      })

      // Cache popular searches
      if (query) {
        const searchKey = `popular_searches:${type}`
        await redis.zincrby(searchKey, 1, query.toLowerCase())
        await redis.expire(searchKey, 7 * 24 * 60 * 60) // 7 days TTL
      }

      res.json({
        success: true,
        ...searchResults
      })

    } catch (error) {
      logger.error('Search error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Search failed' })
    }
  }
)

// Relevance calculation functions
const calculateUserRelevance = (user, query) => {
  if (!query) return 0
  
  let score = 0
  const searchTerms = query.toLowerCase().split(' ')
  
  searchTerms.forEach(term => {
    if (user.firstName?.toLowerCase().includes(term)) score += 10
    if (user.lastName?.toLowerCase().includes(term)) score += 10
    if (user.email?.toLowerCase().includes(term)) score += 5
    if (user.profile?.bio?.toLowerCase().includes(term)) score += 3
    if (user.profile?.skills?.some(skill => skill.toLowerCase().includes(term))) score += 7
  })
  
  // Boost for complete profile
  if (user.profile?.bio && user.avatarUrl) score += 2
  
  // Boost for active users
  if (user.analytics?.totalLogins > 10) score += 3
  
  return score
}

const calculateContentRelevance = (post, query) => {
  if (!query) return 0
  
  let score = 0
  const searchTerms = query.toLowerCase().split(' ')
  
  searchTerms.forEach(term => {
    if (post.title?.toLowerCase().includes(term)) score += 15
    if (post.content?.toLowerCase().includes(term)) score += 5
    if (post.tags?.some(tag => tag.toLowerCase().includes(term))) score += 8
  })
  
  // Boost for popular content
  if (post._count?.likes > 10) score += 3
  if (post._count?.comments > 5) score += 2
  
  return score
}

const calculateProductRelevance = (product, query) => {
  if (!query) return 0
  
  let score = 0
  const searchTerms = query.toLowerCase().split(' ')
  
  searchTerms.forEach(term => {
    if (product.name?.toLowerCase().includes(term)) score += 15
    if (product.description?.toLowerCase().includes(term)) score += 5
    if (product.category?.toLowerCase().includes(term)) score += 8
  })
  
  // Boost for popular products
  if (product._count?.orders > 10) score += 5
  if (product._count?.reviews > 5) score += 3
  
  return score
}

// Background job scheduler
cron.schedule('0 2 * * *', async () => {
  logger.info('Running daily cleanup jobs...')
  
  try {
    // Clean expired sessions
    await prisma.session.deleteMany({
      where: {
        expiresAt: { lt: new Date() }
      }
    })

    // Clean old activities (keep last 90 days)
    const ninetyDaysAgo = new Date()
    ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90)
    
    await prisma.activity.deleteMany({
      where: {
        timestamp: { lt: ninetyDaysAgo }
      }
    })

    // Clean old exports
    const sevenDaysAgo = new Date()
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7)
    
    await prisma.export.deleteMany({
      where: {
        createdAt: { lt: sevenDaysAgo }
      }
    })

    // Update user streaks
    const users = await prisma.user.findMany({
      where: { isActive: true },
      include: { analytics: true }
    })

    for (const user of users) {
      const lastActivity = user.analytics?.lastActivity
      if (lastActivity) {
        const daysSinceActivity = Math.floor((Date.now() - lastActivity.getTime()) / (1000 * 60 * 60 * 24))
        
        if (daysSinceActivity > 1) {
          // Reset streak if more than 1 day of inactivity
          await prisma.userAnalytics.update({
            where: { userId: user.id },
            data: { currentStreak: 0 }
          })
        }
      }
    }

    logger.info('Daily cleanup jobs completed successfully')
    
  } catch (error) {
    logger.error('Daily cleanup jobs failed:', error)
    Sentry.captureException(error)
  }
})

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    services: {
      database: prisma ? 'connected' : 'disconnected',
      redis: redis.status === 'ready' ? 'connected' : 'disconnected',
      rabbitmq: rabbitmqConnection ? 'connected' : 'disconnected',
      stripe: stripe ? 'configured' : 'not_configured'
    },
    version: process.env.npm_package_version || '1.0.0',
    environment: process.env.NODE_ENV || 'development'
  })
})

// Error handling middleware
app.use((error, req, res, next) => {
  logger.error('Unhandled error:', error)
  Sentry.captureException(error)
  
  if (error.name === 'ValidationError') {
    return res.status(400).json({
      error: 'Validation failed',
      details: error.details
    })
  }
  
  if (error.name === 'UnauthorizedError') {
    return res.status(401).json({
      error: 'Unauthorized access'
    })
  }
  
  if (error.code === 'P2002') {
    return res.status(409).json({
      error: 'Resource already exists',
      field: error.meta?.target
    })
  }
  
  res.status(500).json({
    error: 'Internal server error',
    requestId: req.headers['x-request-id'] || 'unknown'
  })
})

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({
    error: 'Endpoint not found',
    method: req.method,
    path: req.originalUrl
  })
})

// Graceful shutdown
process.on('SIGTERM', async () => {
  logger.info('SIGTERM received, starting graceful shutdown...')
  
  try {
    // Close database connections
    await prisma.$disconnect()
    
    // Close Redis connection
    redis.disconnect()
    
    // Close RabbitMQ connection
    if (rabbitmqConnection) {
      await rabbitmqConnection.close()
    }
    
    logger.info('Graceful shutdown completed')
    process.exit(0)
  } catch (error) {
    logger.error('Error during shutdown:', error)
    process.exit(1)
  }
})

process.on('SIGINT', async () => {
  logger.info('SIGINT received, starting graceful shutdown...')
  
  try {
    await prisma.$disconnect()
    redis.disconnect()
    
    if (rabbitmqConnection) {
      await rabbitmqConnection.close()
    }
    
    logger.info('Graceful shutdown completed')
    process.exit(0)
  } catch (error) {
    logger.error('Error during shutdown:', error)
    process.exit(1)
  }
})

// Additional Complex Routes

// Complex Dashboard API with Real-time Data
app.get('/api/dashboard',
  strictRateLimit,
  authenticateJWT,
  async (req, res) => {
    try {
      const userId = req.user.id
      const { timeframe = '7d' } = req.query

      // Calculate date range
      const endDate = new Date()
      const startDate = new Date()
      
      switch (timeframe) {
        case '24h':
          startDate.setHours(endDate.getHours() - 24)
          break
        case '7d':
          startDate.setDate(endDate.getDate() - 7)
          break
        case '30d':
          startDate.setDate(endDate.getDate() - 30)
          break
        case '90d':
          startDate.setDate(endDate.getDate() - 90)
          break
      }

      // Fetch dashboard data in parallel
      const [
        userStats,
        recentActivities,
        notifications,
        realtimeMetrics,
        topContent,
        connections,
        financialStats,
        systemHealth
      ] = await Promise.all([
        // User statistics
        prisma.userAnalytics.findUnique({
          where: { userId }
        }),

        // Recent activities
        prisma.activity.findMany({
          where: {
            userId,
            timestamp: { gte: startDate }
          },
          orderBy: { timestamp: 'desc' },
          take: 10
        }),

        // Unread notifications
        prisma.userNotification.findMany({
          where: {
            userId,
            read: false
          },
          orderBy: { createdAt: 'desc' },
          take: 5
        }),

        // Real-time metrics from Redis
        (async () => {
          const keys = await redis.keys(`analytics:${userId}:*`)
          const metrics = {}
          
          for (const key of keys) {
            const data = await redis.hgetall(key)
            const date = key.split(':')[2]
            metrics[date] = data
          }
          
          return metrics
        })(),

        // Top performing content
        prisma.post.findMany({
          where: {
            authorId: userId,
            createdAt: { gte: startDate }
          },
          include: {
            _count: {
              select: {
                likes: true,
                comments: true,
                shares: true
              }
            }
          },
          orderBy: [
            { views: 'desc' },
            { createdAt: 'desc' }
          ],
          take: 5
        }),

        // Recent connections
        prisma.connection.findMany({
          where: {
            OR: [
              { userId, status: 'accepted' },
              { connectedUserId: userId, status: 'accepted' }
            ],
            createdAt: { gte: startDate }
          },
          include: {
            user: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                avatarUrl: true
              }
            },
            connectedUser: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                avatarUrl: true
              }
            }
          },
          orderBy: { createdAt: 'desc' },
          take: 5
        }),

        // Financial statistics
        prisma.transaction.aggregate({
          where: {
            userId,
            status: 'completed',
            createdAt: { gte: startDate }
          },
          _sum: { amount: true },
          _count: true,
          _avg: { amount: true }
        }),

        // System health check
        (async () => {
          try {
            const dbHealth = await prisma.$queryRaw`SELECT 1`
            const redisHealth = await redis.ping()
            
            return {
              database: !!dbHealth,
              redis: redisHealth === 'PONG',
              timestamp: new Date()
            }
          } catch (error) {
            return {
              database: false,
              redis: false,
              error: error.message,
              timestamp: new Date()
            }
          }
        })()
      ])

      // Process activity trends
      const activityTrends = {}
      recentActivities.forEach(activity => {
        const date = moment(activity.timestamp).format('YYYY-MM-DD')
        if (!activityTrends[date]) {
          activityTrends[date] = {}
        }
        if (!activityTrends[date][activity.action]) {
          activityTrends[date][activity.action] = 0
        }
        activityTrends[date][activity.action]++
      })

      // Calculate growth metrics
      const previousPeriodStart = new Date(startDate)
      const periodLength = endDate - startDate
      previousPeriodStart.setTime(previousPeriodStart.getTime() - periodLength)

      const previousPeriodActivities = await prisma.activity.count({
        where: {
          userId,
          timestamp: {
            gte: previousPeriodStart,
            lt: startDate
          }
        }
      })

      const currentPeriodActivities = recentActivities.length
      const activityGrowth = previousPeriodActivities > 0 
        ? ((currentPeriodActivities - previousPeriodActivities) / previousPeriodActivities) * 100
        : 0

      // Prepare dashboard response
      const dashboardData = {
        user: {
          id: userId,
          name: `${req.user.firstName} ${req.user.lastName}`,
          avatar: req.user.avatarUrl,
          subscriptionPlan: req.user.subscriptionPlan || 'free',
          joinDate: req.user.createdAt
        },
        
        stats: {
          totalLogins: userStats?.totalLogins || 0,
          totalActivities: currentPeriodActivities,
          activityGrowth: Math.round(activityGrowth * 100) / 100,
          lastActivity: userStats?.lastActivity,
          currentStreak: userStats?.currentStreak || 0,
          longestStreak: userStats?.longestStreak || 0
        },

        activities: {
          recent: recentActivities.map(activity => ({
            id: activity.id,
            action: activity.action,
            timestamp: activity.timestamp,
            details: JSON.parse(activity.details || '{}'),
            ipAddress: activity.ipAddress,
            location: activity.location
          })),
          trends: activityTrends,
          total: currentPeriodActivities
        },

        notifications: {
          unread: notifications.map(notification => ({
            id: notification.id,
            title: notification.title,
            message: notification.message,
            type: notification.type,
            priority: notification.priority,
            createdAt: notification.createdAt,
            data: JSON.parse(notification.data || '{}')
          })),
          count: notifications.length
        },

        content: {
          topPosts: topContent.map(post => ({
            id: post.id,
            title: post.title,
            views: post.views,
            engagement: post._count,
            createdAt: post.createdAt
          })),
          totalViews: topContent.reduce((sum, post) => sum + (post.views || 0), 0)
        },

        social: {
          recentConnections: connections.map(conn => ({
            id: conn.id,
            user: conn.userId === userId ? conn.connectedUser : conn.user,
            connectedAt: conn.createdAt
          })),
          totalConnections: connections.length
        },

        financial: {
          totalSpent: financialStats._sum.amount || 0,
          transactionCount: financialStats._count || 0,
          averageTransaction: financialStats._avg.amount || 0,
          currency: 'USD' // Default currency
        },

        realtime: realtimeMetrics,

        system: {
          health: systemHealth,
          performance: {
            responseTime: Date.now() - req.startTime,
            memoryUsage: process.memoryUsage(),
            uptime: process.uptime()
          }
        },

        insights: []
      }

      // Generate insights based on data
      if (dashboardData.stats.activityGrowth > 20) {
        dashboardData.insights.push({
          type: 'positive',
          title: 'Activity Surge',
          message: `Your activity increased by ${dashboardData.stats.activityGrowth.toFixed(1)}% this period!`
        })
      }

      if (dashboardData.stats.currentStreak > 7) {
        dashboardData.insights.push({
          type: 'achievement',
          title: 'Streak Master',
          message: `You're on a ${dashboardData.stats.currentStreak}-day activity streak!`
        })
      }

      if (dashboardData.content.totalViews > 1000) {
        dashboardData.insights.push({
          type: 'milestone',
          title: 'Content Star',
          message: `Your content received over ${dashboardData.content.totalViews} views this period!`
        })
      }

      if (dashboardData.notifications.count > 10) {
        dashboardData.insights.push({
          type: 'warning',
          title: 'Notification Backlog',
          message: `You have ${dashboardData.notifications.count} unread notifications.`
        })
      }

      // Log dashboard access
      await logActivity(userId, 'DASHBOARD_ACCESSED', {
        timeframe,
        loadTime: Date.now() - req.startTime,
        ipAddress: req.ip
      })

      // Process analytics
      await processAnalytics(userId, 'dashboard_view', {
        timeframe,
        hasUnreadNotifications: dashboardData.notifications.count > 0,
        activityTrend: dashboardData.stats.activityGrowth > 0 ? 'up' : 'down'
      })

      res.json({
        success: true,
        data: dashboardData,
        meta: {
          timeframe,
          generatedAt: new Date().toISOString(),
          loadTime: Date.now() - req.startTime
        }
      })

    } catch (error) {
      logger.error('Dashboard error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Dashboard load failed' })
    }
  }
)

// Complex Bulk Operations API
app.post('/api/bulk/:operation',
  strictRateLimit,
  authenticateJWT,
  upload.single('file'),
  [
    param('operation').isIn(['delete', 'update', 'export', 'import', 'process']),
    body('targets').optional().isArray(),
    body('criteria').optional().isJSON(),
    body('data').optional().isJSON(),
    body('options').optional().isJSON()
  ],
  validateRequest,
  async (req, res) => {
    try {
      const { operation } = req.params
      const {
        targets = [],
        criteria = '{}',
        data = '{}',
        options = '{}'
      } = req.body

      const userId = req.user.id
      const parsedCriteria = JSON.parse(criteria)
      const parsedData = JSON.parse(data)
      const parsedOptions = JSON.parse(options)
      const operationId = uuidv4()

      // Check permissions for bulk operations
      if (!req.user.permissions?.bulk?.[operation]) {
        return res.status(403).json({ 
          error: `Insufficient permissions for bulk ${operation}` 
        })
      }

      // Create bulk operation record
      const bulkOperation = await prisma.bulkOperation.create({
        data: {
          id: operationId,
          userId,
          type: operation,
          status: 'processing',
          targetCount: targets.length,
          criteria: parsedCriteria,
          options: parsedOptions,
          createdAt: new Date()
        }
      })

      let results = {
        processed: 0,
        successful: 0,
        failed: 0,
        errors: []
      }

      try {
        switch (operation) {
          case 'delete':
            // Bulk delete operation
            if (parsedCriteria.type === 'posts' && targets.length > 0) {
              // Verify ownership
              const posts = await prisma.post.findMany({
                where: {
                  id: { in: targets },
                  authorId: userId
                }
              })

              for (const post of posts) {
                try {
                  await prisma.$transaction(async (tx) => {
                    // Delete related data first
                    await tx.comment.deleteMany({ where: { postId: post.id } })
                    await tx.like.deleteMany({ where: { postId: post.id } })
                    await tx.share.deleteMany({ where: { postId: post.id } })
                    await tx.bookmark.deleteMany({ where: { postId: post.id } })
                    
                    // Delete the post
                    await tx.post.delete({ where: { id: post.id } })
                  })

                  results.successful++
                } catch (deleteError) {
                  results.failed++
                  results.errors.push({
                    target: post.id,
                    error: deleteError.message
                  })
                }
                results.processed++
              }
            }
            break

          case 'update':
            // Bulk update operation
            if (parsedCriteria.type === 'users' && parsedData.updates) {
              const userIds = targets.length > 0 ? targets : [userId]
              
              for (const targetUserId of userIds) {
                // Check if user can update this target
                if (targetUserId !== userId && !req.user.permissions?.users?.updateOthers) {
                  results.failed++
                  results.errors.push({
                    target: targetUserId,
                    error: 'Insufficient permissions'
                  })
                  continue
                }

                try {
                  await prisma.user.update({
                    where: { id: targetUserId },
                    data: parsedData.updates
                  })
                  results.successful++
                } catch (updateError) {
                  results.failed++
                  results.errors.push({
                    target: targetUserId,
                    error: updateError.message
                  })
                }
                results.processed++
              }
            }
            break

          case 'export':
            // Bulk export operation
            let exportData = []
            let filename = `export-${operationId}.json`
            let contentType = 'application/json'

            if (parsedCriteria.type === 'analytics') {
              const analytics = await prisma.activity.findMany({
                where: {
                  userId,
                  timestamp: {
                    gte: parsedCriteria.startDate ? new Date(parsedCriteria.startDate) : undefined,
                    lte: parsedCriteria.endDate ? new Date(parsedCriteria.endDate) : undefined
                  }
                },
                orderBy: { timestamp: 'desc' },
                take: parsedOptions.limit || 10000
              })

              exportData = analytics.map(activity => ({
                date: activity.timestamp.toISOString(),
                action: activity.action,
                details: JSON.parse(activity.details || '{}'),
                ipAddress: activity.ipAddress,
                location: activity.location
              }))

              // Generate different formats
              if (parsedOptions.format === 'csv') {
                const csvData = [
                  'Date,Action,Details,IP Address,Location',
                  ...exportData.map(row => 
                    `"${row.date}","${row.action}","${JSON.stringify(row.details).replace(/"/g, '""')}","${row.ipAddress || ''}","${row.location || ''}"`
                  )
                ].join('\n')

                exportData = csvData
                filename = `analytics-${operationId}.csv`
                contentType = 'text/csv'
              } else if (parsedOptions.format === 'xlsx') {
                const workbook = new ExcelJS.Workbook()
                const worksheet = workbook.addWorksheet('Analytics')

                worksheet.columns = [
                  { header: 'Date', key: 'date', width: 25 },
                  { header: 'Action', key: 'action', width: 20 },
                  { header: 'Details', key: 'details', width: 40 },
                  { header: 'IP Address', key: 'ipAddress', width: 15 },
                  { header: 'Location', key: 'location', width: 20 }
                ]

                exportData.forEach(row => {
                  worksheet.addRow({
                    date: row.date,
                    action: row.action,
                    details: JSON.stringify(row.details),
                    ipAddress: row.ipAddress,
                    location: row.location
                  })
                })

                exportData = await workbook.xlsx.writeBuffer()
                filename = `analytics-${operationId}.xlsx`
                contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
              }

              results.successful = exportData.length || 1
              results.processed = exportData.length || 1
            }

            // Store export file (in production, upload to S3)
            if (parsedOptions.format !== 'xlsx') {
              await fs.writeFile(`/tmp/${filename}`, typeof exportData === 'string' ? exportData : JSON.stringify(exportData, null, 2))
            } else {
              await fs.writeFile(`/tmp/${filename}`, exportData)
            }

            // Update bulk operation with file info
            await prisma.bulkOperation.update({
              where: { id: operationId },
              data: {
                resultData: JSON.stringify({
                  filename,
                  contentType,
                  size: typeof exportData === 'string' ? exportData.length : Buffer.byteLength(JSON.stringify(exportData))
                })
              }
            })

            break

          case 'process':
            // Bulk process operation (e.g., image processing, data transformation)
            if (req.file && parsedCriteria.type === 'images') {
              const processedImages = []
              
              // This would typically process multiple images from a zip file
              // For demo, we'll process the single uploaded file
              if (req.file.mimetype.startsWith('image/')) {
                try {
                  // Process image with different sizes
                  const sizes = [
                    { name: 'thumbnail', width: 150, height: 150 },
                    { name: 'small', width: 400, height: 300 },
                    { name: 'medium', width: 800, height: 600 },
                    { name: 'large', width: 1200, height: 900 }
                  ]

                  for (const size of sizes) {
                    const processedImage = await processImage(req.file.buffer, {
                      width: size.width,
                      height: size.height,
                      quality: 85,
                      format: 'jpeg'
                    })

                    const imageKey = `processed/${operationId}/${size.name}-${uuidv4()}.jpg`
                    const imageUrl = await uploadToS3(processedImage, imageKey, 'image/jpeg')
                    
                    processedImages.push({
                      size: size.name,
                      url: imageUrl,
                      dimensions: `${size.width}x${size.height}`
                    })
                  }

                  results.successful = processedImages.length
                  results.processed = 1

                  await prisma.bulkOperation.update({
                    where: { id: operationId },
                    data: {
                      resultData: JSON.stringify({ processedImages })
                    }
                  })

                } catch (processError) {
                  results.failed = 1
                  results.errors.push({
                    target: req.file.originalname,
                    error: processError.message
                  })
                }
              }
            }
            break

          default:
            throw new Error(`Unsupported bulk operation: ${operation}`)
        }

        // Update operation status
        await prisma.bulkOperation.update({
          where: { id: operationId },
          data: {
            status: results.failed > 0 ? 'completed_with_errors' : 'completed',
            processedCount: results.processed,
            successCount: results.successful,
            failedCount: results.failed,
            errors: JSON.stringify(results.errors),
            completedAt: new Date()
          }
        })

        // Send completion notification
        const completionHtml = `
          <h2>Bulk ${operation.charAt(0).toUpperCase() + operation.slice(1)} Completed</h2>
          <p>Your bulk operation has finished processing.</p>
          <p><strong>Operation ID:</strong> ${operationId}</p>
          <p><strong>Processed:</strong> ${results.processed}</p>
          <p><strong>Successful:</strong> ${results.successful}</p>
          <p><strong>Failed:</strong> ${results.failed}</p>
          ${results.errors.length > 0 ? `<p><strong>Errors:</strong> ${results.errors.length}</p>` : ''}
          <p>You can view detailed results in your dashboard.</p>
        `

        if (rabbitmqChannel) {
          await rabbitmqChannel.sendToQueue(
            'email_queue',
            Buffer.from(JSON.stringify({
              to: req.user.email,
              subject: `Bulk ${operation} Completed`,
              html: completionHtml,
              priority: 'normal'
            })),
            { persistent: true }
          )
        }

        // Log bulk operation
        await logActivity(userId, 'BULK_OPERATION_COMPLETED', {
          operationId,
          type: operation,
          processed: results.processed,
          successful: results.successful,
          failed: results.failed,
          ipAddress: req.ip
        })

        // Process analytics
        await processAnalytics(userId, 'bulk_operation', {
          type: operation,
          itemCount: results.processed,
          successRate: results.processed > 0 ? (results.successful / results.processed) * 100 : 0,
          hasErrors: results.failed > 0
        })

        res.json({
          success: true,
          message: `Bulk ${operation} completed`,
          operationId,
          results: {
            processed: results.processed,
            successful: results.successful,
            failed: results.failed,
            errors: results.errors.slice(0, 10) // Return first 10 errors
          }
        })

      } catch (operationError) {
        // Update operation as failed
        await prisma.bulkOperation.update({
          where: { id: operationId },
          data: {
            status: 'failed',
            errors: JSON.stringify([{ message: operationError.message }]),
            completedAt: new Date()
          }
        })

        throw operationError
      }

    } catch (error) {
      logger.error('Bulk operation error:', error)
      Sentry.captureException(error)
      res.status(500).json({ error: 'Bulk operation failed', details: error.message })
    }
  }
)

// Export the router
export default app

// Start server if this file is run directly
if (process.env.NODE_ENV !== 'test') {
  const PORT = process.env.PORT || 3001
  const server = app.listen(PORT, () => {
    logger.info(` Server running on port ${PORT}`)
    logger.info(` Environment: ${process.env.NODE_ENV || 'development'}`)
    logger.info(` Started at: ${new Date().toISOString()}`)
  })

  // Socket.io setup for real-time features
  const io = socketio(server, {
    cors: {
      origin: process.env.FRONTEND_URL || 'http://localhost:3000',
      methods: ['GET', 'POST']
    }
  })

  // Socket authentication middleware
  io.use(async (socket, next) => {
    try {
      const token = socket.handshake.auth.token
      if (!token) {
        return next(new Error('Authentication token required'))
      }

      const decoded = jwt.verify(token, process.env.JWT_SECRET)
      const user = await userLoader.load(decoded.userId)

      if (!user || !user.isActive) {
        return next(new Error('Invalid or inactive user'))
      }

      socket.userId = user.id
      socket.user = user
      next()
    } catch (error) {
      next(new Error('Authentication failed'))
    }
  })

  // Socket connection handling
  io.on('connection', (socket) => {
    logger.info(`User ${socket.userId} connected via Socket.IO`)
    
    // Join user-specific room
    socket.join(`user:${socket.userId}`)
    
    // Handle real-time activity tracking
    socket.on('activity', async (data) => {
      try {
        await processAnalytics(socket.userId, 'realtime_activity', {
          type: data.type,
          page: data.page,
          duration: data.duration
        })
        
        // Update last activity
        await redis.setex(`user_activity:${socket.userId}`, 300, Date.now()) // 5 min TTL
      } catch (error) {
        logger.error('Real-time activity error:', error)
      }
    })
    
    // Handle typing indicators for chat
    socket.on('typing_start', (data) => {
      socket.to(`conversation:${data.conversationId}`).emit('user_typing', {
        userId: socket.userId,
        userName: `${socket.user.firstName} ${socket.user.lastName}`
      })
    })
    
    socket.on('typing_stop', (data) => {
      socket.to(`conversation:${data.conversationId}`).emit('user_stopped_typing', {
        userId: socket.userId
      })
    })
    
    // Handle presence updates
    socket.on('presence_update', async (status) => {
      try {
        await redis.setex(`presence:${socket.userId}`, 300, JSON.stringify({
          status,
          lastSeen: Date.now(),
          socketId: socket.id
        }))
        
        // Broadcast to connections
        socket.broadcast.emit('user_presence_updated', {
          userId: socket.userId,
          status,
          timestamp: Date.now()
        })
      } catch (error) {
        logger.error('Presence update error:', error)
      }
    })
    
    socket.on('disconnect', async (reason) => {
      logger.info(`User ${socket.userId} disconnected: ${reason}`)
      
      // Update presence to offline
      try {
        await redis.setex(`presence:${socket.userId}`, 300, JSON.stringify({
          status: 'offline',
          lastSeen: Date.now(),
          socketId: null
        }))
        
        socket.broadcast.emit('user_presence_updated', {
          userId: socket.userId,
          status: 'offline',
          timestamp: Date.now()
        })
      } catch (error) {
        logger.error('Disconnect presence update error:', error)
      }
    })
  })

  // Store io instance for use in other parts of the app
  app.set('io', io)

  // Handle server shutdown
  server.on('close', async () => {
    logger.info('HTTP server closing...')
    io.close()
  })
}
